(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.bondage = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn) {
	  var module = { exports: {} };
		return fn(module, module.exports), module.exports;
	}

	function commonjsRequire (path) {
		throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
	}

	var parser_1 = createCommonjsModule(function (module, exports) {
	/* parser generated by jison 0.6.1-215 */

	/*
	 * Returns a Parser object of the following structure:
	 *
	 *  Parser: {
	 *    yy: {}     The so-called "shared state" or rather the *source* of it;
	 *               the real "shared state" `yy` passed around to
	 *               the rule actions, etc. is a derivative/copy of this one,
	 *               not a direct reference!
	 *  }
	 *
	 *  Parser.prototype: {
	 *    yy: {},
	 *    EOF: 1,
	 *    TERROR: 2,
	 *
	 *    trace: function(errorMessage, ...),
	 *
	 *    JisonParserError: function(msg, hash),
	 *
	 *    quoteName: function(name),
	 *               Helper function which can be overridden by user code later on: put suitable
	 *               quotes around literal IDs in a description string.
	 *
	 *    originalQuoteName: function(name),
	 *               The basic quoteName handler provided by JISON.
	 *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function
	 *               at the end of the `parse()`.
	 *
	 *    describeSymbol: function(symbol),
	 *               Return a more-or-less human-readable description of the given symbol, when
	 *               available, or the symbol itself, serving as its own 'description' for lack
	 *               of something better to serve up.
	 *
	 *               Return NULL when the symbol is unknown to the parser.
	 *
	 *    symbols_: {associative list: name ==> number},
	 *    terminals_: {associative list: number ==> name},
	 *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},
	 *    terminal_descriptions_: (if there are any) {associative list: number ==> description},
	 *    productions_: [...],
	 *
	 *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),
	 *
	 *               The function parameters and `this` have the following value/meaning:
	 *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)
	 *                             to store/reference the rule value `$$` and location info `@$`.
	 *
	 *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets
	 *                 to see the same object via the `this` reference, i.e. if you wish to carry custom
	 *                 data from one reduce action through to the next within a single parse run, then you
	 *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.
	 *
	 *                 `this.yy` is a direct reference to the `yy` shared state object.
	 *
	 *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`
	 *                 object at `parse()` start and are therefore available to the action code via the
	 *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from
	 *                 the %parse-param` list.
	 *
	 *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used
	 *                             to match this rule. This is *not* the look-ahead token, but the last token
	 *                             that's actually part of this rule.
	 *
	 *                 Formulated another way, `yytext` is the value of the token immediately preceeding
	 *                 the current look-ahead token.
	 *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.
	 *
	 *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.
	 *
	 *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.
	 *
	 *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.
	 *
	 *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead
	 *                               of an empty object when no suitable location info can be provided.
	 *
	 *               - `yystate` : the current parser state number, used internally for dispatching and
	 *                               executing the action code chunk matching the rule currently being reduced.
	 *
	 *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')
	 *
	 *                 This one comes in handy when you are going to do advanced things to the parser
	 *                 stacks, all of which are accessible from your action code (see the next entries below).
	 *
	 *                 Also note that you can access this and other stack index values using the new double-hash
	 *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things
	 *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.
	 *                 This is made available to write very advanced grammar action rules, e.g. when you want
	 *                 to investigate the parse state stack in your action code, which would, for example,
	 *                 be relevant when you wish to implement error diagnostics and reporting schemes similar
	 *                 to the work described here:
	 *
	 *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.
	 *                   In Journées Francophones des Languages Applicatifs.
	 *
	 *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.
	 *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631–640.
	 *
	 *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.
	 *
	 *                 This one comes in handy when you are going to do advanced things to the parser
	 *                 stacks, all of which are accessible from your action code (see the next entries below).
	 *
	 *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.
	 *                             constructs.
	 *
	 *               - `yylstack`: reference to the parser token location stack. Also accessed via
	 *                             the `@1` etc. constructs.
	 *
	 *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are
	 *                             UNDEFINED rather than an empty (location) object, when the lexer/parser
	 *                             action code did not provide a suitable location info object when such a
	 *                             slot was filled!
	 *
	 *               - `yystack` : reference to the parser token id stack. Also accessed via the
	 *                             `#1` etc. constructs.
	 *
	 *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to
	 *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might
	 *                 want access this array for your own purposes, such as error analysis as mentioned above!
	 *
	 *                 Note that this stack stores the current stack of *tokens*, that is the sequence of
	 *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*
	 *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and
	 *                 *reduced*.
	 *
	 *               - `yysstack`: reference to the parser state stack. This one carries the internal parser
	 *                             *states* such as the one in `yystate`, which are used to represent
	 *                             the parser state machine in the *parse table*. *Very* *internal* stuff,
	 *                             what can I say? If you access this one, you're clearly doing wicked things
	 *
	 *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your
	 *                             grammar definition file.
	 *
	 *    table: [...],
	 *               State transition table
	 *               ----------------------
	 *
	 *               index levels are:
	 *               - `state`  --> hash table
	 *               - `symbol` --> action (number or array)
	 *
	 *                 If the `action` is an array, these are the elements' meaning:
	 *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept
	 *                 - index [1]: GOTO `state`
	 *
	 *                 If the `action` is a number, it is the GOTO `state`
	 *
	 *    defaultActions: {...},
	 *
	 *    parseError: function(str, hash, ExceptionClass),
	 *    yyError: function(str, ...),
	 *    yyRecovering: function(),
	 *    yyErrOk: function(),
	 *    yyClearIn: function(),
	 *
	 *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),
	 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
	 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
	 *               See it's use in this parser kernel in many places; example usage:
	 *
	 *                   var infoObj = parser.constructParseErrorInfo('fail!', null,
	 *                                     parser.collect_expected_token_set(state), true);
	 *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);
	 *
	 *    originalParseError: function(str, hash, ExceptionClass),
	 *               The basic `parseError` handler provided by JISON.
	 *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function
	 *               at the end of the `parse()`.
	 *
	 *    options: { ... parser %options ... },
	 *
	 *    parse: function(input[, args...]),
	 *               Parse the given `input` and return the parsed value (or `true` when none was provided by
	 *               the root action, in which case the parser is acting as a *matcher*).
	 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:
	 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
	 *
	 *               WARNING:
	 *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with
	 *               any attributes already added to `yy` by the jison run-time;
	 *               when such a collision is detected an exception is thrown to prevent the generated run-time
	 *               from silently accepting this confusing and potentially hazardous situation!
	 *
	 *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in
	 *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state
	 *               object and any collision with those will be reported by the lexer via a thrown exception.
	 *
	 *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),
	 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
	 *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown
	 *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY
	 *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and
	 *               the internal parser gets properly garbage collected under these particular circumstances.
	 *
	 *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),
	 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
	 *               This helper API can be invoked to calculate a spanning `yylloc` location info object.
	 *
	 *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case
	 *               this function will attempt to obtain a suitable location marker by inspecting the location stack
	 *               backwards.
	 *
	 *               For more info see the documentation comment further below, immediately above this function's
	 *               implementation.
	 *
	 *    lexer: {
	 *        yy: {...},           A reference to the so-called "shared state" `yy` once
	 *                             received via a call to the `.setInput(input, yy)` lexer API.
	 *        EOF: 1,
	 *        ERROR: 2,
	 *        JisonLexerError: function(msg, hash),
	 *        parseError: function(str, hash, ExceptionClass),
	 *        setInput: function(input, [yy]),
	 *        input: function(),
	 *        unput: function(str),
	 *        more: function(),
	 *        reject: function(),
	 *        less: function(n),
	 *        pastInput: function(n),
	 *        upcomingInput: function(n),
	 *        showPosition: function(),
	 *        test_match: function(regex_match_array, rule_index, ...),
	 *        next: function(...),
	 *        lex: function(...),
	 *        begin: function(condition),
	 *        pushState: function(condition),
	 *        popState: function(),
	 *        topState: function(),
	 *        _currentRules: function(),
	 *        stateStackSize: function(),
	 *        cleanupAfterLex: function()
	 *
	 *        options: { ... lexer %options ... },
	 *
	 *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),
	 *        rules: [...],
	 *        conditions: {associative list: name ==> set},
	 *    }
	 *  }
	 *
	 *
	 *  token location info (@$, _$, etc.): {
	 *    first_line: n,
	 *    last_line: n,
	 *    first_column: n,
	 *    last_column: n,
	 *    range: [start_number, end_number]
	 *               (where the numbers are indexes into the input string, zero-based)
	 *  }
	 *
	 * ---
	 *
	 * The `parseError` function receives a 'hash' object with these members for lexer and
	 * parser errors:
	 *
	 *  {
	 *    text:        (matched text)
	 *    token:       (the produced terminal token, if any)
	 *    token_id:    (the produced terminal token numeric ID, if any)
	 *    line:        (yylineno)
	 *    loc:         (yylloc)
	 *  }
	 *
	 * parser (grammar) errors will also provide these additional members:
	 *
	 *  {
	 *    expected:    (array describing the set of expected tokens;
	 *                  may be UNDEFINED when we cannot easily produce such a set)
	 *    state:       (integer (or array when the table includes grammar collisions);
	 *                  represents the current internal state of the parser kernel.
	 *                  can, for example, be used to pass to the `collect_expected_token_set()`
	 *                  API to obtain the expected token set)
	 *    action:      (integer; represents the current internal action which will be executed)
	 *    new_state:   (integer; represents the next/planned internal state, once the current
	 *                  action has executed)
	 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
	 *                  available for this particular error)
	 *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,
	 *                  for instance, for advanced error analysis and reporting)
	 *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,
	 *                  for instance, for advanced error analysis and reporting)
	 *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,
	 *                  for instance, for advanced error analysis and reporting)
	 *    yy:          (object: the current parser internal "shared state" `yy`
	 *                  as is also available in the rule actions; this can be used,
	 *                  for instance, for advanced error analysis and reporting)
	 *    lexer:       (reference to the current lexer instance used by the parser)
	 *    parser:      (reference to the current parser instance)
	 *  }
	 *
	 * while `this` will reference the current parser instance.
	 *
	 * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*
	 * instance, while these additional `hash` fields will also be provided:
	 *
	 *  {
	 *    lexer:       (reference to the current lexer instance which reported the error)
	 *  }
	 *
	 * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired
	 * from either the parser or lexer, `this` will still reference the related *parser*
	 * instance, while these additional `hash` fields will also be provided:
	 *
	 *  {
	 *    exception:   (reference to the exception thrown)
	 *  }
	 *
	 * Please do note that in the latter situation, the `expected` field will be omitted as
	 * this type of failure is assumed not to be due to *parse errors* but rather due to user
	 * action code in either parser or lexer failing unexpectedly.
	 *
	 * ---
	 *
	 * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.
	 * These options are available:
	 *
	 * ### options which are global for all parser instances
	 *
	 *  Parser.pre_parse: function(yy)
	 *                 optional: you can specify a pre_parse() function in the chunk following
	 *                 the grammar, i.e. after the last `%%`.
	 *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }
	 *                 optional: you can specify a post_parse() function in the chunk following
	 *                 the grammar, i.e. after the last `%%`. When it does not return any value,
	 *                 the parser will return the original `retval`.
	 *
	 * ### options which can be set up per parser instance
	 *
	 *  yy: {
	 *      pre_parse:  function(yy)
	 *                 optional: is invoked before the parse cycle starts (and before the first
	 *                 invocation of `lex()`) but immediately after the invocation of
	 *                 `parser.pre_parse()`).
	 *      post_parse: function(yy, retval, parseInfo) { return retval; }
	 *                 optional: is invoked when the parse terminates due to success ('accept')
	 *                 or failure (even when exceptions are thrown).
	 *                 `retval` contains the return value to be produced by `Parser.parse()`;
	 *                 this function can override the return value by returning another.
	 *                 When it does not return any value, the parser will return the original
	 *                 `retval`.
	 *                 This function is invoked immediately before `parser.post_parse()`.
	 *
	 *      parseError: function(str, hash, ExceptionClass)
	 *                 optional: overrides the default `parseError` function.
	 *      quoteName: function(name),
	 *                 optional: overrides the default `quoteName` function.
	 *  }
	 *
	 *  parser.lexer.options: {
	 *      pre_lex:  function()
	 *                 optional: is invoked before the lexer is invoked to produce another token.
	 *                 `this` refers to the Lexer object.
	 *      post_lex: function(token) { return token; }
	 *                 optional: is invoked when the lexer has produced a token `token`;
	 *                 this function can override the returned token value by returning another.
	 *                 When it does not return any (truthy) value, the lexer will return
	 *                 the original `token`.
	 *                 `this` refers to the Lexer object.
	 *
	 *      ranges: boolean
	 *                 optional: `true` ==> token location info will include a .range[] member.
	 *      flex: boolean
	 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
	 *                 exhaustively to find the longest match.
	 *      backtrack_lexer: boolean
	 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
	 *                 the lexer terminates the scan when a token is returned by the action code.
	 *      xregexp: boolean
	 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
	 *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer
	 *                 rule regexes have been written as standard JavaScript RegExp expressions.
	 *  }
	 */

	        
	    
	            var parser = (function () {


	// See also:
	// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
	// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
	// with userland code which might access the derived class in a 'classic' way.
	function JisonParserError(msg, hash) {
	    Object.defineProperty(this, 'name', {
	        enumerable: false,
	        writable: false,
	        value: 'JisonParserError'
	    });

	    if (msg == null) msg = '???';

	    Object.defineProperty(this, 'message', {
	        enumerable: false,
	        writable: true,
	        value: msg
	    });

	    this.hash = hash;

	    var stacktrace;
	    if (hash && hash.exception instanceof Error) {
	        var ex2 = hash.exception;
	        this.message = ex2.message || msg;
	        stacktrace = ex2.stack;
	    }
	    if (!stacktrace) {
	        if (Error.hasOwnProperty('captureStackTrace')) {        // V8/Chrome engine
	            Error.captureStackTrace(this, this.constructor);
	        } else {
	            stacktrace = (new Error(msg)).stack;
	        }
	    }
	    if (stacktrace) {
	        Object.defineProperty(this, 'stack', {
	            enumerable: false,
	            writable: false,
	            value: stacktrace
	        });
	    }
	}

	if (typeof Object.setPrototypeOf === 'function') {
	    Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);
	} else {
	    JisonParserError.prototype = Object.create(Error.prototype);
	}
	JisonParserError.prototype.constructor = JisonParserError;
	JisonParserError.prototype.name = 'JisonParserError';




	        // helper: reconstruct the productions[] table
	        function bp(s) {
	            var rv = [];
	            var p = s.pop;
	            var r = s.rule;
	            for (var i = 0, l = p.length; i < l; i++) {
	                rv.push([
	                    p[i],
	                    r[i]
	                ]);
	            }
	            return rv;
	        }
	    


	        // helper: reconstruct the defaultActions[] table
	        function bda(s) {
	            var rv = {};
	            var d = s.idx;
	            var g = s.goto;
	            for (var i = 0, l = d.length; i < l; i++) {
	                var j = d[i];
	                rv[j] = g[i];
	            }
	            return rv;
	        }
	    


	        // helper: reconstruct the 'goto' table
	        function bt(s) {
	            var rv = [];
	            var d = s.len;
	            var y = s.symbol;
	            var t = s.type;
	            var a = s.state;
	            var m = s.mode;
	            var g = s.goto;
	            for (var i = 0, l = d.length; i < l; i++) {
	                var n = d[i];
	                var q = {};
	                for (var j = 0; j < n; j++) {
	                    var z = y.shift();
	                    switch (t.shift()) {
	                    case 2:
	                        q[z] = [
	                            m.shift(),
	                            g.shift()
	                        ];
	                        break;

	                    case 0:
	                        q[z] = a.shift();
	                        break;

	                    default:
	                        // type === 1: accept
	                        q[z] = [
	                            3
	                        ];
	                    }
	                }
	                rv.push(q);
	            }
	            return rv;
	        }
	    


	        // helper: runlength encoding with increment step: code, length: step (default step = 0)
	        // `this` references an array
	        function s(c, l, a) {
	            a = a || 0;
	            for (var i = 0; i < l; i++) {
	                this.push(c);
	                c += a;
	            }
	        }

	        // helper: duplicate sequence from *relative* offset and length.
	        // `this` references an array
	        function c(i, l) {
	            i = this.length - i;
	            for (l += i; i < l; i++) {
	                this.push(this[i]);
	            }
	        }

	        // helper: unpack an array using helpers and data, all passed in an array argument 'a'.
	        function u(a) {
	            var rv = [];
	            for (var i = 0, l = a.length; i < l; i++) {
	                var e = a[i];
	                // Is this entry a helper function?
	                if (typeof e === 'function') {
	                    i++;
	                    e.apply(rv, a[i]);
	                } else {
	                    rv.push(e);
	                }
	            }
	            return rv;
	        }
	    

	var parser = {
	    // Code Generator Information Report
	    // ---------------------------------
	    //
	    // Options:
	    //
	    //   default action mode: ............. ["classic","merge"]
	    //   test-compile action mode: ........ "parser:*,lexer:*"
	    //   try..catch: ...................... true
	    //   default resolve on conflict: ..... true
	    //   on-demand look-ahead: ............ undefined
	    //   error recovery token skip maximum: 3
	    //   yyerror in parse actions is: ..... NOT recoverable,
	    //   yyerror in lexer actions and other non-fatal lexer are:
	    //   .................................. NOT recoverable,
	    //   debug grammar/output: ............ false
	    //   has partial LR conflict upgrade:   false
	    //   rudimentary token-stack support:   false
	    //   parser table compression mode: ... 2
	    //   export debug tables: ............. false
	    //   export *all* tables: ............. false
	    //   module type: ..................... commonjs
	    //   parser engine type: .............. slr
	    //   output main() in the module: ..... true
	    //   has user-specified main(): ....... false
	    //   has user-specified require()/import modules for main():
	    //   .................................. false
	    //   number of expected conflicts: .... 0
	    //
	    //
	    // Parser Analysis flags:
	    //
	    //   no significant actions (parser is a language matcher only):
	    //   .................................. false
	    //   uses yyleng: ..................... false
	    //   uses yylineno: ................... false
	    //   uses yytext: ..................... false
	    //   uses yylloc: ..................... false
	    //   uses ParseError API: ............. false
	    //   uses YYERROR: .................... false
	    //   uses YYRECOVERING: ............... false
	    //   uses YYERROK: .................... false
	    //   uses YYCLEARIN: .................. false
	    //   tracks rule values: .............. true
	    //   assigns rule values: ............. true
	    //   uses location tracking: .......... true
	    //   assigns location: ................ true
	    //   uses yystack: .................... false
	    //   uses yysstack: ................... false
	    //   uses yysp: ....................... true
	    //   uses yyrulelength: ............... false
	    //   uses yyMergeLocationInfo API: .... true
	    //   has error recovery: .............. false
	    //   has error reporting: ............. false
	    //
	    // --------- END OF REPORT -----------

	trace: function no_op_trace() { },
	JisonParserError: JisonParserError,
	yy: {},
	options: {
	  type: "slr",
	  errorRecoveryTokenDiscardCount: 3
	},
	symbols_: {
	  "$accept": 0,
	  "$end": 1,
	  "%prec": 32,
	  "Add": 36,
	  "AddAssign": 22,
	  "And": 41,
	  "BeginCommand": 4,
	  "Comma": 49,
	  "CommandCall": 14,
	  "Dedent": 13,
	  "Divide": 39,
	  "DivideAssign": 25,
	  "EOF": 1,
	  "Else": 8,
	  "ElseIf": 9,
	  "EndCommand": 6,
	  "EndIf": 7,
	  "EndOfInput": 3,
	  "EqualTo": 43,
	  "EqualToOrAssign": 21,
	  "False": 27,
	  "GreaterThan": 45,
	  "GreaterThanOrEqualTo": 46,
	  "Identifier": 18,
	  "If": 5,
	  "Indent": 12,
	  "LeftParen": 34,
	  "LessThan": 47,
	  "LessThanOrEqualTo": 48,
	  "Minus": 37,
	  "MinusAssign": 23,
	  "Multiply": 38,
	  "MultiplyAssign": 24,
	  "Not": 33,
	  "NotEqualTo": 44,
	  "Null": 30,
	  "Number": 28,
	  "OptionDelimit": 17,
	  "OptionEnd": 16,
	  "OptionStart": 15,
	  "Or": 40,
	  "RightParen": 35,
	  "Set": 19,
	  "ShortcutOption": 11,
	  "String": 29,
	  "Text": 10,
	  "True": 26,
	  "UnaryMinus": 31,
	  "Variable": 20,
	  "Xor": 42,
	  "additionalConditionalStatements": 53,
	  "argument": 63,
	  "arguments": 62,
	  "assignment": 59,
	  "command": 56,
	  "conditionalStatement": 52,
	  "error": 2,
	  "expression": 60,
	  "functionResultExpression": 61,
	  "jump": 57,
	  "link": 58,
	  "node": 50,
	  "shortcut": 55,
	  "statement": 54,
	  "statements": 51
	},
	terminals_: {
	  1: "EOF",
	  2: "error",
	  3: "EndOfInput",
	  4: "BeginCommand",
	  5: "If",
	  6: "EndCommand",
	  7: "EndIf",
	  8: "Else",
	  9: "ElseIf",
	  10: "Text",
	  11: "ShortcutOption",
	  12: "Indent",
	  13: "Dedent",
	  14: "CommandCall",
	  15: "OptionStart",
	  16: "OptionEnd",
	  17: "OptionDelimit",
	  18: "Identifier",
	  19: "Set",
	  20: "Variable",
	  21: "EqualToOrAssign",
	  22: "AddAssign",
	  23: "MinusAssign",
	  24: "MultiplyAssign",
	  25: "DivideAssign",
	  26: "True",
	  27: "False",
	  28: "Number",
	  29: "String",
	  30: "Null",
	  31: "UnaryMinus",
	  32: "%prec",
	  33: "Not",
	  34: "LeftParen",
	  35: "RightParen",
	  36: "Add",
	  37: "Minus",
	  38: "Multiply",
	  39: "Divide",
	  40: "Or",
	  41: "And",
	  42: "Xor",
	  43: "EqualTo",
	  44: "NotEqualTo",
	  45: "GreaterThan",
	  46: "GreaterThanOrEqualTo",
	  47: "LessThan",
	  48: "LessThanOrEqualTo",
	  49: "Comma"
	},
	TERROR: 2,
	    EOF: 1,

	    // internals: defined here so the object *structure* doesn't get modified by parse() et al,
	    // thus helping JIT compilers like Chrome V8.
	    originalQuoteName: null,
	    originalParseError: null,
	    cleanupAfterParse: null,
	    constructParseErrorInfo: null,
	    yyMergeLocationInfo: null,

	    __reentrant_call_depth: 0,      // INTERNAL USE ONLY
	    __error_infos: [],              // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup
	    __error_recovery_infos: [],     // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup

	    // APIs which will be set up depending on user action code analysis:
	    //yyRecovering: 0,
	    //yyErrOk: 0,
	    //yyClearIn: 0,

	    // Helper APIs
	    // -----------

	    // Helper function which can be overridden by user code later on: put suitable quotes around
	    // literal IDs in a description string.
	    quoteName: function parser_quoteName(id_str) {
	        return '"' + id_str + '"';
	    },

	    // Return the name of the given symbol (terminal or non-terminal) as a string, when available.
	    //
	    // Return NULL when the symbol is unknown to the parser.
	    getSymbolName: function parser_getSymbolName(symbol) {
	        if (this.terminals_[symbol]) {
	            return this.terminals_[symbol];
	        }

	        // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.
	        //
	        // An example of this may be where a rule's action code contains a call like this:
	        //
	        //      parser.getSymbolName(#$)
	        //
	        // to obtain a human-readable name of the current grammar rule.
	        var s = this.symbols_;
	        for (var key in s) {
	            if (s[key] === symbol) {
	                return key;
	            }
	        }
	        return null;
	    },

	    // Return a more-or-less human-readable description of the given symbol, when available,
	    // or the symbol itself, serving as its own 'description' for lack of something better to serve up.
	    //
	    // Return NULL when the symbol is unknown to the parser.
	    describeSymbol: function parser_describeSymbol(symbol) {
	        if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {
	            return this.terminal_descriptions_[symbol];
	        }
	        else if (symbol === this.EOF) {
	            return 'end of input';
	        }
	        var id = this.getSymbolName(symbol);
	        if (id) {
	            return this.quoteName(id);
	        }
	        return null;
	    },

	    // Produce a (more or less) human-readable list of expected tokens at the point of failure.
	    //
	    // The produced list may contain token or token set descriptions instead of the tokens
	    // themselves to help turning this output into something that easier to read by humans
	    // unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,
	    // expected terminals and nonterminals is produced.
	    //
	    // The returned list (array) will not contain any duplicate entries.
	    collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {
	        var TERROR = this.TERROR;
	        var tokenset = [];
	        var check = {};
	        // Has this (error?) state been outfitted with a custom expectations description text for human consumption?
	        // If so, use that one instead of the less palatable token set.
	        if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {
	            return [
	                this.state_descriptions_[state]
	            ];
	        }
	        for (var p in this.table[state]) {
	            p = +p;
	            if (p !== TERROR) {
	                var d = do_not_describe ? p : this.describeSymbol(p);
	                if (d && !check[d]) {
	                    tokenset.push(d);
	                    check[d] = true;        // Mark this token description as already mentioned to prevent outputting duplicate entries.
	                }
	            }
	        }
	        return tokenset;
	    },
	productions_: bp({
	  pop: u([
	  50,
	  s,
	  [51, 4],
	  52,
	  52,
	  s,
	  [53, 3],
	  s,
	  [54, 6],
	  55,
	  s,
	  [55, 5, 1],
	  s,
	  [59, 4],
	  s,
	  [60, 24],
	  61,
	  62,
	  62,
	  s,
	  [63, 3]
	]),
	  rule: u([
	  s,
	  [2, 3],
	  1,
	  1,
	  8,
	  6,
	  7,
	  8,
	  6,
	  s,
	  [1, 6],
	  5,
	  9,
	  3,
	  3,
	  5,
	  s,
	  [6, 5],
	  s,
	  [1, 6],
	  4,
	  4,
	  2,
	  s,
	  [3, 14],
	  1,
	  4,
	  3,
	  s,
	  [1, 4]
	])
	}),
	performAction: function parser__PerformAction(yyloc, yystate /* action[1] */, yysp, yyvstack, yylstack) {

	          /* this == yyval */

	          // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!
	          var yy = this.yy;
	          var yyparser = yy.parser;
	          yy.lexer;

	          

	          switch (yystate) {
	case 0:
	    /*! Production::    $accept : node $end */

	    // default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,LT,LA,-,-):
	    this.$ = yyvstack[yysp - 1];
	    this._$ = yylstack[yysp - 1];
	    // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,LT,LA,-,-)
	    break;

	case 1:
	    /*! Production::    node : statements EndOfInput */

	    // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-):
	    this.$ = yyvstack[yysp - 1];
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-)
	    
	    
	    JSON.stringify(yyvstack[yysp - 1], null, "  "); return yyvstack[yysp - 1];

	case 2:
	    /*! Production::    statements : statements conditionalStatement */
	case 3:
	    /*! Production::    statements : statements statement */

	    // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = yyvstack[yysp - 1].concat([yyvstack[yysp]]);
	    break;

	case 4:
	    /*! Production::    statements : conditionalStatement */
	case 5:
	    /*! Production::    statements : statement */
	case 53:
	    /*! Production::    arguments : argument */

	    // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yylstack[yysp];
	    // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = [yyvstack[yysp]];
	    break;

	case 6:
	    /*! Production::    conditionalStatement : BeginCommand If expression EndCommand statements BeginCommand EndIf EndCommand */

	    // default action (generated by JISON mode classic/merge :: 8,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 8,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = new yy.IfNode(yyvstack[yysp - 5], yyvstack[yysp - 3]);
	    break;

	case 7:
	    /*! Production::    conditionalStatement : BeginCommand If expression EndCommand statements additionalConditionalStatements */

	    // default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = new yy.IfElseNode(yyvstack[yysp - 3], yyvstack[yysp - 1], yyvstack[yysp]);
	    break;

	case 8:
	    /*! Production::    additionalConditionalStatements : BeginCommand Else EndCommand statements BeginCommand EndIf EndCommand */

	    // default action (generated by JISON mode classic/merge :: 7,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 7,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = new yy.ElseNode(yyvstack[yysp - 3]);
	    break;

	case 9:
	    /*! Production::    additionalConditionalStatements : BeginCommand ElseIf expression EndCommand statements BeginCommand EndIf EndCommand */

	    // default action (generated by JISON mode classic/merge :: 8,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 8,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = new yy.ElseIfNode(yyvstack[yysp - 5], yyvstack[yysp - 3]);
	    break;

	case 10:
	    /*! Production::    additionalConditionalStatements : BeginCommand ElseIf expression EndCommand statements additionalConditionalStatements */

	    // default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = new yy.ElseIfNode(yyvstack[yysp - 3], yyvstack[yysp - 1], yyvstack[yysp]);
	    break;

	case 11:
	    /*! Production::    statement : shortcut */
	case 12:
	    /*! Production::    statement : command */
	case 13:
	    /*! Production::    statement : jump */
	case 14:
	    /*! Production::    statement : link */
	case 15:
	    /*! Production::    statement : assignment */
	case 50:
	    /*! Production::    expression : functionResultExpression */

	    // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yylstack[yysp];
	    // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = yyvstack[yysp];
	    break;

	case 16:
	    /*! Production::    statement : Text */

	    // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):
	    this._$ = yylstack[yysp];
	    // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)
	    
	    
	    this.$ = new yy.TextNode(yyvstack[yysp], this._$);
	    break;

	case 17:
	    /*! Production::    shortcut : ShortcutOption Text Indent statements Dedent */

	    // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)
	    
	    
	    this.$ = new yy.DialogOptionNode(yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
	    break;

	case 18:
	    /*! Production::    shortcut : ShortcutOption Text BeginCommand If expression EndCommand Indent statements Dedent */

	    // default action (generated by JISON mode classic/merge :: 9,VT,VA,VU,-,LT,LA,LU,LUbA):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 8, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 9,VT,VA,VU,-,LT,LA,LU,LUbA)
	    
	    
	    this.$ = new yy.ConditionalDialogOptionNode(yyvstack[yysp - 7], yyvstack[yysp - 1], yyvstack[yysp - 4], this._$);
	    break;

	case 19:
	    /*! Production::    command : BeginCommand CommandCall EndCommand */

	    // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)
	    
	    
	    this.$ = new yy.CommandNode(yyvstack[yysp - 1], this._$);
	    break;

	case 20:
	    /*! Production::    jump : OptionStart Text OptionEnd */

	    // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)
	    
	    
	    this.$ = new yy.JumpNode(yyvstack[yysp - 1], this._$);
	    break;

	case 21:
	    /*! Production::    link : OptionStart Text OptionDelimit Identifier OptionEnd */

	    // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)
	    
	    
	    this.$ = new yy.LinkNode(yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
	    break;

	case 22:
	    /*! Production::    assignment : BeginCommand Set Variable EqualToOrAssign expression EndCommand */

	    // default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = new yy.SetVariableEqualToNode(yyvstack[yysp - 3].substring(1), yyvstack[yysp - 1]);
	    break;

	case 23:
	    /*! Production::    assignment : BeginCommand Set Variable AddAssign expression EndCommand */

	    // default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = new yy.SetVariableAddNode(yyvstack[yysp - 3].substring(1), yyvstack[yysp - 1]);
	    break;

	case 24:
	    /*! Production::    assignment : BeginCommand Set Variable MinusAssign expression EndCommand */

	    // default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = new yy.SetVariableMinusNode(yyvstack[yysp - 3].substring(1), yyvstack[yysp - 1]);
	    break;

	case 25:
	    /*! Production::    assignment : BeginCommand Set Variable MultiplyAssign expression EndCommand */

	    // default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = new yy.SetVariableMultipyNode(yyvstack[yysp - 3].substring(1), yyvstack[yysp - 1]);
	    break;

	case 26:
	    /*! Production::    assignment : BeginCommand Set Variable DivideAssign expression EndCommand */

	    // default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = new yy.SetVariableDivideNode(yyvstack[yysp - 3].substring(1), yyvstack[yysp - 1]);
	    break;

	case 27:
	    /*! Production::    expression : True */
	case 28:
	    /*! Production::    expression : False */

	    // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yylstack[yysp];
	    // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = new yy.BooleanLiteralNode(yyvstack[yysp]);
	    break;

	case 29:
	    /*! Production::    expression : Number */
	case 54:
	    /*! Production::    argument : Number */

	    // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yylstack[yysp];
	    // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = new yy.NumericLiteralNode(yyvstack[yysp]);
	    break;

	case 30:
	    /*! Production::    expression : String */
	case 55:
	    /*! Production::    argument : String */

	    // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yylstack[yysp];
	    // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = new yy.StringLiteralNode(yyvstack[yysp]);
	    break;

	case 31:
	    /*! Production::    expression : Null */

	    // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yylstack[yysp];
	    // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = new yy.NullLiteralNode(yyvstack[yysp]);
	    break;

	case 32:
	    /*! Production::    expression : Variable */
	case 56:
	    /*! Production::    argument : Variable */

	    // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yylstack[yysp];
	    // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = new yy.VariableNode(yyvstack[yysp].substring(1));
	    break;

	case 33:
	    /*! Production::    expression : UnaryMinus Number "%prec" UnaryMinus */

	    // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = new yy.UnaryMinusExpressionNode(yyvstack[yysp - 2]);
	    break;

	case 34:
	    /*! Production::    expression : UnaryMinus Variable "%prec" UnaryMinus */

	    // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = new yy.UnaryMinusExpressionNode(yyvstack[yysp - 2].substring(1));
	    break;

	case 35:
	    /*! Production::    expression : Not expression */

	    // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = new yy.NegatedBooleanExpressionNode(yyvstack[yysp]);
	    break;

	case 36:
	    /*! Production::    expression : LeftParen expression RightParen */

	    // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = new yy.ArithmeticExpressionNode(yyvstack[yysp - 1]);
	    break;

	case 37:
	    /*! Production::    expression : expression Add expression */

	    // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = new yy.ArithmeticExpressionAddNode(yyvstack[yysp - 2], yyvstack[yysp]);
	    break;

	case 38:
	    /*! Production::    expression : expression Minus expression */

	    // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = new yy.ArithmeticExpressionMinusNode(yyvstack[yysp - 2], yyvstack[yysp]);
	    break;

	case 39:
	    /*! Production::    expression : expression Multiply expression */

	    // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = new yy.ArithmeticExpressionMultiplyNode(yyvstack[yysp - 2], yyvstack[yysp]);
	    break;

	case 40:
	    /*! Production::    expression : expression Divide expression */

	    // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = new yy.ArithmeticExpressionDivideNode(yyvstack[yysp - 2], yyvstack[yysp]);
	    break;

	case 41:
	    /*! Production::    expression : expression Or expression */

	    // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = new yy.BooleanOrExpressionNode(yyvstack[yysp - 2], yyvstack[yysp]);
	    break;

	case 42:
	    /*! Production::    expression : expression And expression */

	    // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = new yy.BooleanAndExpressionNode(yyvstack[yysp - 2], yyvstack[yysp]);
	    break;

	case 43:
	    /*! Production::    expression : expression Xor expression */

	    // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = new yy.BooleanXorExpressionNode(yyvstack[yysp - 2], yyvstack[yysp]);
	    break;

	case 44:
	    /*! Production::    expression : expression EqualTo expression */

	    // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = new yy.EqualToExpressionNode(yyvstack[yysp - 2], yyvstack[yysp]);
	    break;

	case 45:
	    /*! Production::    expression : expression NotEqualTo expression */

	    // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = new yy.NotEqualToExpressionNode(yyvstack[yysp - 2], yyvstack[yysp]);
	    break;

	case 46:
	    /*! Production::    expression : expression GreaterThan expression */

	    // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = new yy.GreaterThanExpressionNode(yyvstack[yysp - 2], yyvstack[yysp]);
	    break;

	case 47:
	    /*! Production::    expression : expression GreaterThanOrEqualTo expression */

	    // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = new yy.GreaterThanOrEqualToExpressionNode(yyvstack[yysp - 2], yyvstack[yysp]);
	    break;

	case 48:
	    /*! Production::    expression : expression LessThan expression */

	    // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = new yy.LessThanExpressionNode(yyvstack[yysp - 2], yyvstack[yysp]);
	    break;

	case 49:
	    /*! Production::    expression : expression LessThanOrEqualTo expression */

	    // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = new yy.LessThanOrEqualToExpressionNode(yyvstack[yysp - 2], yyvstack[yysp]);
	    break;

	case 51:
	    /*! Production::    functionResultExpression : Identifier LeftParen arguments RightParen */

	    // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = new yy.FunctionResultNode(yyvstack[yysp - 3], yyvstack[yysp - 1]);
	    break;

	case 52:
	    /*! Production::    arguments : arguments Comma argument */

	    // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
	    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
	    // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
	    
	    
	    this.$ = yyvstack[yysp - 2].concat([yyvstack[yysp]]);
	    break;

	}
	},
	table: bt({
	  len: u([
	  12,
	  1,
	  12,
	  0,
	  0,
	  3,
	  s,
	  [0, 6],
	  1,
	  1,
	  s,
	  [0, 3],
	  12,
	  1,
	  1,
	  2,
	  2,
	  14,
	  s,
	  [0, 6],
	  2,
	  12,
	  12,
	  0,
	  1,
	  0,
	  5,
	  12,
	  1,
	  0,
	  1,
	  s,
	  [12, 14],
	  c,
	  [42, 3],
	  14,
	  5,
	  c,
	  [12, 8],
	  12,
	  15,
	  15,
	  0,
	  0,
	  s,
	  [15, 9],
	  c,
	  [27, 3],
	  2,
	  s,
	  [0, 4],
	  s,
	  [14, 5],
	  0,
	  14,
	  0,
	  6,
	  s,
	  [0, 4],
	  4,
	  c,
	  [96, 7],
	  c,
	  [109, 3],
	  12,
	  0,
	  12,
	  14,
	  12,
	  11,
	  12,
	  0,
	  4,
	  12,
	  1,
	  c,
	  [27, 3],
	  1,
	  0
	]),
	  symbol: u([
	  4,
	  10,
	  11,
	  15,
	  51,
	  52,
	  s,
	  [54, 6, 1],
	  1,
	  3,
	  c,
	  [14, 4],
	  c,
	  [13, 7],
	  5,
	  14,
	  19,
	  10,
	  10,
	  18,
	  20,
	  s,
	  [26, 6, 1],
	  33,
	  34,
	  60,
	  61,
	  6,
	  20,
	  4,
	  12,
	  16,
	  17,
	  6,
	  s,
	  [36, 13, 1],
	  20,
	  28,
	  c,
	  [34, 12],
	  c,
	  [12, 12],
	  34,
	  s,
	  [21, 5, 1],
	  c,
	  [94, 12],
	  5,
	  18,
	  c,
	  [14, 12],
	  c,
	  [56, 24],
	  c,
	  [12, 132],
	  32,
	  32,
	  s,
	  [35, 14, 1],
	  20,
	  28,
	  29,
	  62,
	  63,
	  c,
	  [81, 60],
	  c,
	  [249, 3],
	  13,
	  c,
	  [344, 8],
	  c,
	  [24, 12],
	  16,
	  c,
	  [368, 5],
	  s,
	  [53, 7, 1],
	  6,
	  c,
	  [117, 14],
	  c,
	  [15, 150],
	  31,
	  31,
	  35,
	  49,
	  c,
	  [515, 14],
	  c,
	  [14, 70],
	  5,
	  7,
	  8,
	  9,
	  14,
	  19,
	  c,
	  [361, 3],
	  63,
	  12,
	  6,
	  6,
	  c,
	  [315, 15],
	  c,
	  [564, 9],
	  c,
	  [12, 12],
	  c,
	  [63, 14],
	  c,
	  [353, 12],
	  c,
	  [708, 11],
	  c,
	  [639, 13],
	  7,
	  14,
	  19,
	  c,
	  [367, 13],
	  c,
	  [115, 6],
	  6
	]),
	  type: u([
	  s,
	  [2, 4],
	  s,
	  [0, 8],
	  1,
	  s,
	  [2, 5],
	  s,
	  [0, 7],
	  s,
	  [2, 15],
	  c,
	  [17, 17],
	  s,
	  [2, 17],
	  c,
	  [34, 12],
	  c,
	  [12, 14],
	  c,
	  [81, 12],
	  c,
	  [14, 14],
	  c,
	  [56, 30],
	  c,
	  [12, 130],
	  c,
	  [81, 76],
	  c,
	  [249, 24],
	  c,
	  [274, 18],
	  s,
	  [2, 252],
	  c,
	  [263, 14],
	  c,
	  [278, 6],
	  c,
	  [290, 12],
	  c,
	  [302, 27],
	  c,
	  [38, 18],
	  c,
	  [49, 20],
	  c,
	  [16, 16]
	]),
	  state: u([
	  2,
	  3,
	  4,
	  s,
	  [6, 5, 1],
	  15,
	  16,
	  c,
	  [7, 5],
	  22,
	  32,
	  56,
	  32,
	  57,
	  32,
	  64,
	  c,
	  [21, 7],
	  67,
	  c,
	  [8, 7],
	  68,
	  32,
	  69,
	  32,
	  70,
	  32,
	  71,
	  32,
	  72,
	  32,
	  73,
	  32,
	  74,
	  32,
	  75,
	  32,
	  76,
	  32,
	  77,
	  32,
	  78,
	  32,
	  79,
	  32,
	  80,
	  32,
	  84,
	  85,
	  89,
	  32,
	  90,
	  32,
	  91,
	  32,
	  92,
	  32,
	  93,
	  32,
	  c,
	  [67, 7],
	  95,
	  32,
	  15,
	  98,
	  c,
	  [10, 6],
	  112,
	  116,
	  32,
	  117,
	  c,
	  [66, 7],
	  118,
	  c,
	  [103, 14],
	  c,
	  [7, 7],
	  122,
	  c,
	  [22, 8],
	  125,
	  c,
	  [16, 6]
	]),
	  mode: u([
	  s,
	  [1, 301],
	  s,
	  [2, 4],
	  c,
	  [6, 6],
	  s,
	  [2, 9],
	  c,
	  [15, 13],
	  c,
	  [36, 5],
	  c,
	  [45, 10],
	  c,
	  [6, 10],
	  c,
	  [15, 11],
	  c,
	  [16, 7],
	  c,
	  [15, 9],
	  c,
	  [60, 13],
	  c,
	  [15, 68],
	  s,
	  [1, 161]
	]),
	  goto: u([
	  5,
	  s,
	  [11, 4, 1],
	  c,
	  [5, 4],
	  s,
	  [17, 5, 1],
	  33,
	  28,
	  s,
	  [23, 5, 1],
	  29,
	  30,
	  31,
	  34,
	  35,
	  37,
	  36,
	  s,
	  [38, 16, 1],
	  55,
	  54,
	  c,
	  [32, 10],
	  c,
	  [10, 10],
	  s,
	  [58, 6, 1],
	  c,
	  [67, 4],
	  65,
	  66,
	  c,
	  [6, 4],
	  c,
	  [36, 20],
	  c,
	  [10, 110],
	  81,
	  82,
	  83,
	  c,
	  [184, 13],
	  88,
	  86,
	  87,
	  c,
	  [69, 50],
	  c,
	  [203, 3],
	  94,
	  c,
	  [204, 11],
	  96,
	  97,
	  c,
	  [219, 3],
	  s,
	  [37, 4],
	  43,
	  44,
	  s,
	  [37, 9],
	  s,
	  [38, 4],
	  43,
	  44,
	  s,
	  [38, 9],
	  s,
	  [41, 3],
	  c,
	  [118, 3],
	  41,
	  c,
	  [118, 8],
	  42,
	  42,
	  c,
	  [15, 4],
	  42,
	  42,
	  c,
	  [15, 7],
	  43,
	  43,
	  c,
	  [15, 4],
	  s,
	  [43, 3],
	  c,
	  [15, 6],
	  44,
	  44,
	  c,
	  [15, 4],
	  s,
	  [44, 9],
	  45,
	  45,
	  c,
	  [178, 5],
	  s,
	  [45, 8],
	  46,
	  46,
	  c,
	  [15, 4],
	  s,
	  [46, 9],
	  47,
	  47,
	  c,
	  [15, 4],
	  s,
	  [47, 9],
	  48,
	  48,
	  c,
	  [15, 4],
	  s,
	  [48, 9],
	  49,
	  49,
	  c,
	  [15, 4],
	  s,
	  [49, 9],
	  s,
	  [99, 5, 1],
	  c,
	  [256, 13],
	  104,
	  c,
	  [14, 13],
	  105,
	  c,
	  [14, 13],
	  106,
	  c,
	  [14, 13],
	  107,
	  c,
	  [14, 13],
	  108,
	  c,
	  [14, 13],
	  17,
	  109,
	  110,
	  111,
	  18,
	  19,
	  c,
	  [332, 3],
	  113,
	  114,
	  115,
	  c,
	  [295, 13],
	  13,
	  c,
	  [4, 4],
	  119,
	  c,
	  [44, 13],
	  c,
	  [18, 3],
	  120,
	  13,
	  121,
	  c,
	  [27, 7],
	  17,
	  123,
	  18,
	  19,
	  124,
	  c,
	  [8, 3],
	  126,
	  17,
	  127,
	  c,
	  [66, 4],
	  128
	])
	}),
	defaultActions: bda({
	  idx: u([
	  3,
	  4,
	  s,
	  [6, 6, 1],
	  14,
	  15,
	  16,
	  s,
	  [23, 6, 1],
	  32,
	  34,
	  38,
	  56,
	  70,
	  71,
	  83,
	  s,
	  [85, 4, 1],
	  94,
	  96,
	  s,
	  [98, 4, 1],
	  s,
	  [103, 5, 1],
	  112,
	  114,
	  120,
	  125,
	  126,
	  128
	]),
	  goto: u([
	  4,
	  5,
	  s,
	  [11, 6, 1],
	  1,
	  2,
	  3,
	  s,
	  [27, 6, 1],
	  50,
	  19,
	  20,
	  35,
	  39,
	  40,
	  36,
	  s,
	  [53, 4, 1],
	  17,
	  21,
	  7,
	  33,
	  34,
	  51,
	  s,
	  [22, 5, 1],
	  52,
	  6,
	  18,
	  10,
	  8,
	  9
	])
	}),
	parseError: function parseError(str, hash, ExceptionClass) {
	    if (hash.recoverable) {
	        if (typeof this.trace === 'function') {
	            this.trace(str);
	        }
	        hash.destroy();             // destroy... well, *almost*!
	    } else {
	        if (typeof this.trace === 'function') {
	            this.trace(str);
	        }
	        if (!ExceptionClass) {
	            ExceptionClass = this.JisonParserError;
	        }
	        throw new ExceptionClass(str, hash);
	    }
	},
	parse: function parse(input) {
	    var self = this;
	    var stack = new Array(128);         // token stack: stores token which leads to state at the same index (column storage)
	    var sstack = new Array(128);        // state stack: stores states (column storage)

	    var vstack = new Array(128);        // semantic value stack
	    var lstack = new Array(128);        // location stack
	    var table = this.table;
	    var sp = 0;                         // 'stack pointer': index into the stacks
	    var yyloc;

	    


	    var symbol = 0;



	    this.TERROR;
	    var EOF = this.EOF;
	    (this.options.errorRecoveryTokenDiscardCount | 0) || 3;
	    var NO_ACTION = [0, 129 /* === table.length :: ensures that anyone using this new state will fail dramatically! */];

	    var lexer;
	    if (this.__lexer__) {
	        lexer = this.__lexer__;
	    } else {
	        lexer = this.__lexer__ = Object.create(this.lexer);
	    }

	    var sharedState_yy = {
	        parseError: undefined,
	        quoteName: undefined,
	        lexer: undefined,
	        parser: undefined,
	        pre_parse: undefined,
	        post_parse: undefined,
	        pre_lex: undefined,
	        post_lex: undefined      // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!
	    };
	    if (typeof assert !== 'function') ; else {
	        assert;
	    }

	    this.yyGetSharedState = function yyGetSharedState() {
	        return sharedState_yy;
	    };


	    // shallow clone objects, straight copy of simple `src` values
	    // e.g. `lexer.yytext` MAY be a complex value object,
	    // rather than a simple string/value.
	    function shallow_copy(src) {
	        if (typeof src === 'object') {
	            var dst = {};
	            for (var k in src) {
	                if (Object.prototype.hasOwnProperty.call(src, k)) {
	                    dst[k] = src[k];
	                }
	            }
	            return dst;
	        }
	        return src;
	    }
	    function shallow_copy_noclobber(dst, src) {
	        for (var k in src) {
	            if (typeof dst[k] === 'undefined' && Object.prototype.hasOwnProperty.call(src, k)) {
	                dst[k] = src[k];
	            }
	        }
	    }
	    function copy_yylloc(loc) {
	        var rv = shallow_copy(loc);
	        if (rv && rv.range) {
	            rv.range = rv.range.slice(0);
	        }
	        return rv;
	    }

	    // copy state
	    shallow_copy_noclobber(sharedState_yy, this.yy);

	    sharedState_yy.lexer = lexer;
	    sharedState_yy.parser = this;






	    // Does the shared state override the default `parseError` that already comes with this instance?
	    if (typeof sharedState_yy.parseError === 'function') {
	        this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {
	            if (!ExceptionClass) {
	                ExceptionClass = this.JisonParserError;
	            }
	            return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);
	        };
	    } else {
	        this.parseError = this.originalParseError;
	    }

	    // Does the shared state override the default `quoteName` that already comes with this instance?
	    if (typeof sharedState_yy.quoteName === 'function') {
	        this.quoteName = function quoteNameAlt(id_str) {
	            return sharedState_yy.quoteName.call(this, id_str);
	        };
	    } else {
	        this.quoteName = this.originalQuoteName;
	    }

	    // set up the cleanup function; make it an API so that external code can re-use this one in case of
	    // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which
	    // case this parse() API method doesn't come with a `finally { ... }` block any more!
	    //
	    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
	    //       or else your `sharedState`, etc. references will be *wrong*!
	    this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {
	        var rv;

	        if (invoke_post_methods) {
	            var hash;

	            if (sharedState_yy.post_parse || this.post_parse) {
	                // create an error hash info instance: we re-use this API in a **non-error situation**
	                // as this one delivers all parser internals ready for access by userland code.
	                hash = this.constructParseErrorInfo(null /* no error! */, null /* no exception! */, null, false);
	            }

	            if (sharedState_yy.post_parse) {
	                rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);
	                if (typeof rv !== 'undefined') resultValue = rv;
	            }
	            if (this.post_parse) {
	                rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);
	                if (typeof rv !== 'undefined') resultValue = rv;
	            }

	            // cleanup:
	            if (hash && hash.destroy) {
	                hash.destroy();
	            }
	        }

	        if (this.__reentrant_call_depth > 1) return resultValue;        // do not (yet) kill the sharedState when this is a reentrant run.

	        // clean up the lingering lexer structures as well:
	        if (lexer.cleanupAfterLex) {
	            lexer.cleanupAfterLex(do_not_nuke_errorinfos);
	        }

	        // prevent lingering circular references from causing memory leaks:
	        if (sharedState_yy) {
	            sharedState_yy.lexer = undefined;
	            sharedState_yy.parser = undefined;
	            if (lexer.yy === sharedState_yy) {
	                lexer.yy = undefined;
	            }
	        }
	        sharedState_yy = undefined;
	        this.parseError = this.originalParseError;
	        this.quoteName = this.originalQuoteName;

	        // nuke the vstack[] array at least as that one will still reference obsoleted user values.
	        // To be safe, we nuke the other internal stack columns as well...
	        stack.length = 0;               // fastest way to nuke an array without overly bothering the GC
	        sstack.length = 0;
	        lstack.length = 0;
	        vstack.length = 0;
	        sp = 0;

	        // nuke the error hash info instances created during this run.
	        // Userland code must COPY any data/references
	        // in the error hash instance(s) it is more permanently interested in.
	        if (!do_not_nuke_errorinfos) {
	            for (var i = this.__error_infos.length - 1; i >= 0; i--) {
	                var el = this.__error_infos[i];
	                if (el && typeof el.destroy === 'function') {
	                    el.destroy();
	                }
	            }
	            this.__error_infos.length = 0;


	        }

	        return resultValue;
	    };

	    // merge yylloc info into a new yylloc instance.
	    //
	    // `first_index` and `last_index` MAY be UNDEFINED/NULL or these are indexes into the `lstack[]` location stack array.
	    //
	    // `first_yylloc` and `last_yylloc` MAY be UNDEFINED/NULL or explicit (custom or regular) `yylloc` instances, in which
	    // case these override the corresponding first/last indexes.
	    //
	    // `dont_look_back` is an optional flag (default: FALSE), which instructs this merge operation NOT to search
	    // through the parse location stack for a location, which would otherwise be used to construct the new (epsilon!)
	    // yylloc info.
	    //
	    // Note: epsilon rule's yylloc situation is detected by passing both `first_index` and `first_yylloc` as UNDEFINED/NULL.
	    this.yyMergeLocationInfo = function parser_yyMergeLocationInfo(first_index, last_index, first_yylloc, last_yylloc, dont_look_back) {
	        var i1 = first_index | 0,
	            i2 = last_index | 0;
	        var l1 = first_yylloc,
	            l2 = last_yylloc;
	        var rv;

	        // rules:
	        // - first/last yylloc entries override first/last indexes

	        if (!l1) {
	            if (first_index != null) {
	                for (var i = i1; i <= i2; i++) {
	                    l1 = lstack[i];
	                    if (l1) {
	                        break;
	                    }
	                }
	            }
	        }

	        if (!l2) {
	            if (last_index != null) {
	                for (var i = i2; i >= i1; i--) {
	                    l2 = lstack[i];
	                    if (l2) {
	                        break;
	                    }
	                }
	            }
	        }

	        // - detect if an epsilon rule is being processed and act accordingly:
	        if (!l1 && first_index == null) {
	            // epsilon rule span merger. With optional look-ahead in l2.
	            if (!dont_look_back) {
	                for (var i = (i1 || sp) - 1; i >= 0; i--) {
	                    l1 = lstack[i];
	                    if (l1) {
	                        break;
	                    }
	                }
	            }
	            if (!l1) {
	                if (!l2) {
	                    // when we still don't have any valid yylloc info, we're looking at an epsilon rule
	                    // without look-ahead and no preceding terms and/or `dont_look_back` set:
	                    // in that case we ca do nothing but return NULL/UNDEFINED:
	                    return undefined;
	                } else {
	                    // shallow-copy L2: after all, we MAY be looking
	                    // at unconventional yylloc info objects...
	                    rv = shallow_copy(l2);
	                    if (rv.range) {
	                        // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:
	                        rv.range = rv.range.slice(0);
	                    }
	                    return rv;
	                }
	            } else {
	                // shallow-copy L1, then adjust first col/row 1 column past the end.
	                rv = shallow_copy(l1);
	                rv.first_line = rv.last_line;
	                rv.first_column = rv.last_column;
	                if (rv.range) {
	                    // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:
	                    rv.range = rv.range.slice(0);
	                    rv.range[0] = rv.range[1];
	                }

	                if (l2) {
	                    // shallow-mixin L2, then adjust last col/row accordingly.
	                    shallow_copy_noclobber(rv, l2);
	                    rv.last_line = l2.last_line;
	                    rv.last_column = l2.last_column;
	                    if (rv.range && l2.range) {
	                        rv.range[1] = l2.range[1];
	                    }
	                }
	                return rv;
	            }
	        }

	        if (!l1) {
	            l1 = l2;
	            l2 = null;
	        }
	        if (!l1) {
	            return undefined;
	        }

	        // shallow-copy L1|L2, before we try to adjust the yylloc values: after all, we MAY be looking
	        // at unconventional yylloc info objects...
	        rv = shallow_copy(l1);

	        // first_line: ...,
	        // first_column: ...,
	        // last_line: ...,
	        // last_column: ...,
	        if (rv.range) {
	            // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:
	            rv.range = rv.range.slice(0);
	        }

	        if (l2) {
	            shallow_copy_noclobber(rv, l2);
	            rv.last_line = l2.last_line;
	            rv.last_column = l2.last_column;
	            if (rv.range && l2.range) {
	                rv.range[1] = l2.range[1];
	            }
	        }

	        return rv;
	    };

	    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
	    //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!
	    this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {
	        var pei = {
	            errStr: msg,
	            exception: ex,
	            text: lexer.match,
	            value: lexer.yytext,
	            token: this.describeSymbol(symbol) || symbol,
	            token_id: symbol,
	            line: lexer.yylineno,
	            loc: copy_yylloc(lexer.yylloc),
	            expected: expected,
	            recoverable: recoverable,
	            state: state,
	            action: action,
	            new_state: newState,
	            symbol_stack: stack,
	            state_stack: sstack,
	            value_stack: vstack,
	            location_stack: lstack,
	            stack_pointer: sp,
	            yy: sharedState_yy,
	            lexer: lexer,
	            parser: this,

	            // and make sure the error info doesn't stay due to potential
	            // ref cycle via userland code manipulations.
	            // These would otherwise all be memory leak opportunities!
	            //
	            // Note that only array and object references are nuked as those
	            // constitute the set of elements which can produce a cyclic ref.
	            // The rest of the members is kept intact as they are harmless.
	            destroy: function destructParseErrorInfo() {
	                // remove cyclic references added to error info:
	                // info.yy = null;
	                // info.lexer = null;
	                // info.value = null;
	                // info.value_stack = null;
	                // ...
	                var rec = !!this.recoverable;
	                for (var key in this) {
	                    if (this.hasOwnProperty(key) && typeof key === 'object') {
	                        this[key] = undefined;
	                    }
	                }
	                this.recoverable = rec;
	            }
	        };
	        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
	        this.__error_infos.push(pei);
	        return pei;
	    };


	    function stdLex() {
	        var token = lexer.lex();
	        // if token isn't its numeric value, convert
	        if (typeof token !== 'number') {
	            token = self.symbols_[token] || token;
	        }

	        return token || EOF;
	    }

	    function fastLex() {
	        var token = lexer.fastLex();
	        // if token isn't its numeric value, convert
	        if (typeof token !== 'number') {
	            token = self.symbols_[token] || token;
	        }

	        return token || EOF;
	    }

	    var lex = stdLex;


	    var state, action, r, t;
	    var yyval = {
	        $: true,
	        _$: undefined,
	        yy: sharedState_yy
	    };
	    var p;
	    var yyrulelen;
	    var this_production;
	    var newState;
	    var retval = false;


	    try {
	        this.__reentrant_call_depth++;

	        lexer.setInput(input, sharedState_yy);

	        // NOTE: we *assume* no lexer pre/post handlers are set up *after* 
	        // this initial `setInput()` call: hence we can now check and decide
	        // whether we'll go with the standard, slower, lex() API or the
	        // `fast_lex()` one:
	        if (typeof lexer.canIUse === 'function') {
	            var lexerInfo = lexer.canIUse();
	            if (lexerInfo.fastLex && typeof fastLex === 'function') {
	                lex = fastLex;
	            }
	        } 

	        yyloc = lexer.yylloc;
	        lstack[sp] = yyloc;
	        vstack[sp] = null;
	        sstack[sp] = 0;
	        stack[sp] = 0;
	        ++sp;





	        if (this.pre_parse) {
	            this.pre_parse.call(this, sharedState_yy);
	        }
	        if (sharedState_yy.pre_parse) {
	            sharedState_yy.pre_parse.call(this, sharedState_yy);
	        }

	        newState = sstack[sp - 1];
	        for (;;) {
	            // retrieve state number from top of stack
	            state = newState;               // sstack[sp - 1];

	            // use default actions if available
	            if (this.defaultActions[state]) {
	                action = 2;
	                newState = this.defaultActions[state];
	            } else {
	                // The single `==` condition below covers both these `===` comparisons in a single
	                // operation:
	                //
	                //     if (symbol === null || typeof symbol === 'undefined') ...
	                if (!symbol) {
	                    symbol = lex();
	                }
	                // read action for current state and first input
	                t = (table[state] && table[state][symbol]) || NO_ACTION;
	                newState = t[1];
	                action = t[0];











	                // handle parse error
	                if (!action) {
	                    var errStr;
	                    var errSymbolDescr = (this.describeSymbol(symbol) || symbol);
	                    var expected = this.collect_expected_token_set(state);

	                    // Report error
	                    if (typeof lexer.yylineno === 'number') {
	                        errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ': ';
	                    } else {
	                        errStr = 'Parse error: ';
	                    }
	                    if (typeof lexer.showPosition === 'function') {
	                        errStr += '\n' + lexer.showPosition(79 - 10, 10) + '\n';
	                    }
	                    if (expected.length) {
	                        errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;
	                    } else {
	                        errStr += 'Unexpected ' + errSymbolDescr;
	                    }
	                    // we cannot recover from the error!
	                    p = this.constructParseErrorInfo(errStr, null, expected, false);
	                    r = this.parseError(p.errStr, p, this.JisonParserError);
	                    if (typeof r !== 'undefined') {
	                        retval = r;
	                    }
	                    break;
	                }


	            }










	            switch (action) {
	            // catch misc. parse failures:
	            default:
	                // this shouldn't happen, unless resolve defaults are off
	                if (action instanceof Array) {
	                    p = this.constructParseErrorInfo('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol, null, null, false);
	                    r = this.parseError(p.errStr, p, this.JisonParserError);
	                    if (typeof r !== 'undefined') {
	                        retval = r;
	                    }
	                    break;
	                }
	                // Another case of better safe than sorry: in case state transitions come out of another error recovery process
	                // or a buggy LUT (LookUp Table):
	                p = this.constructParseErrorInfo('Parsing halted. No viable error recovery approach available due to internal system failure.', null, null, false);
	                r = this.parseError(p.errStr, p, this.JisonParserError);
	                if (typeof r !== 'undefined') {
	                    retval = r;
	                }
	                break;

	            // shift:
	            case 1:
	                stack[sp] = symbol;
	                vstack[sp] = lexer.yytext;
	                lstack[sp] = copy_yylloc(lexer.yylloc);
	                sstack[sp] = newState; // push state

	                ++sp;
	                symbol = 0;




	                // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:



	                yyloc = lexer.yylloc;
	                continue;

	            // reduce:
	            case 2:



	                this_production = this.productions_[newState - 1];  // `this.productions_[]` is zero-based indexed while states start from 1 upwards...
	                yyrulelen = this_production[1];










	                r = this.performAction.call(yyval, yyloc, newState, sp - 1, vstack, lstack);

	                if (typeof r !== 'undefined') {
	                    retval = r;
	                    break;
	                }

	                // pop off stack
	                sp -= yyrulelen;

	                // don't overwrite the `symbol` variable: use a local var to speed things up:
	                var ntsymbol = this_production[0];    // push nonterminal (reduce)
	                stack[sp] = ntsymbol;
	                vstack[sp] = yyval.$;
	                lstack[sp] = yyval._$;
	                // goto new state = table[STATE][NONTERMINAL]
	                newState = table[sstack[sp - 1]][ntsymbol];
	                sstack[sp] = newState;
	                ++sp;









	                continue;

	            // accept:
	            case 3:
	                if (sp !== -2) {
	                    retval = true;
	                    // Return the `$accept` rule's `$$` result, if available.
	                    //
	                    // Also note that JISON always adds this top-most `$accept` rule (with implicit,
	                    // default, action):
	                    //
	                    //     $accept: <startSymbol> $end
	                    //                  %{ $$ = $1; @$ = @1; %}
	                    //
	                    // which, combined with the parse kernel's `$accept` state behaviour coded below,
	                    // will produce the `$$` value output of the <startSymbol> rule as the parse result,
	                    // IFF that result is *not* `undefined`. (See also the parser kernel code.)
	                    //
	                    // In code:
	                    //
	                    //                  %{
	                    //                      @$ = @1;            // if location tracking support is included
	                    //                      if (typeof $1 !== 'undefined')
	                    //                          return $1;
	                    //                      else
	                    //                          return true;           // the default parse result if the rule actions don't produce anything
	                    //                  %}
	                    sp--;
	                    if (typeof vstack[sp] !== 'undefined') {
	                        retval = vstack[sp];
	                    }
	                }
	                break;
	            }

	            // break out of loop: we accept or fail with error
	            break;
	        }
	    } catch (ex) {
	        // report exceptions through the parseError callback too, but keep the exception intact
	        // if it is a known parser or lexer error which has been thrown by parseError() already:
	        if (ex instanceof this.JisonParserError) {
	            throw ex;
	        }
	        else if (lexer && typeof lexer.JisonLexerError === 'function' && ex instanceof lexer.JisonLexerError) {
	            throw ex;
	        }

	        p = this.constructParseErrorInfo('Parsing aborted due to exception.', ex, null, false);
	        retval = false;
	        r = this.parseError(p.errStr, p, this.JisonParserError);
	        if (typeof r !== 'undefined') {
	            retval = r;
	        }
	    } finally {
	        retval = this.cleanupAfterParse(retval, true, true);
	        this.__reentrant_call_depth--;
	    }   // /finally

	    return retval;
	}
	};
	parser.originalParseError = parser.parseError;
	parser.originalQuoteName = parser.quoteName;



	function Parser() {
	  this.yy = {};
	}
	Parser.prototype = parser;
	parser.Parser = Parser;

	return new Parser();
	})();

	        


	if (typeof commonjsRequire !== 'undefined' && 'object' !== 'undefined') {
	  exports.parser = parser;
	  exports.Parser = parser.Parser;
	  exports.parse = function () {
	    return parser.parse.apply(parser, arguments);
	  };
	  
	}
	});

	/* eslint-disable key-spacing */
	/**
	 * Token identifier -> regular expression to match the lexeme. That's a list of all the token
	 * which can be emitted by the lexer. For now, we're slightly bending the style guide,
	 * to make sure the debug output of the javascript lexer will (kinda) match the original C# one.
	 */
	const Tokens = {
	  // Special tokens
	  Whitespace:           null,                      // (not used currently)
	  Indent:               null,
	  Dedent:               null,
	  EndOfLine:            null,                      // (not used currently)
	  EndOfInput:           null,

	  UnaryMinus:           null,                      // -; this is differentiated from Minus
	                                                   // when parsing expressions (Not used currently)

	  // Literals in ("<<commands>>")
	  Number:               /-?[0-9]+(\.[0-9+])?/,
	  String:               /"([^"\\]*(?:\\.[^"\\]*)*)"/,

	  // Command syntax ("<<foo>>")
	  BeginCommand:         /<</,
	  EndCommand:           />>/,

	  // Variables ("$foo")
	  Variable:             /\$([A-Za-z0-9_.])+/,

	  // Shortcut syntax ("->")
	  ShortcutOption:       /->/,

	  // Option syntax ("[[Let's go here|Destination]]")
	  OptionStart:          /\[\[/,                    // [[
	  OptionDelimit:        /\|/,                      // |
	  OptionEnd:            /\]\]/,                    // ]]

	  // Command types (specially recognised command word)
	  If:                   /if(?!\w)/,
	  ElseIf:               /elseif(?!\w)/,
	  Else:                 /else(?!\w)/,
	  EndIf:                /endif(?!\w)/,
	  Set:                  /set(?!\w)/,

	  // Boolean values
	  True:                 /true(?!\w)/,
	  False:                /false(?!\w)/,

	  // The null value
	  Null:                 /null(?!\w)/,

	  // Parentheses
	  LeftParen:            /\(/,
	  RightParen:           /\)/,

	  // Parameter delimiters
	  Comma:                /,/,

	  // Operators
	  EqualTo:              /(==|is(?!\w)|eq(?!\w))/,  // ==, eq, is
	  GreaterThan:          /(>|gt(?!\w))/,            // >, gt
	  GreaterThanOrEqualTo: /(>=|gte(?!\w))/,          // >=, gte
	  LessThan:             /(<|lt(?!\w))/,            // <, lt
	  LessThanOrEqualTo:    /(<=|lte(?!\w))/,          // <=, lte
	  NotEqualTo:           /(!=|neq(?!\w))/,          // !=, neq

	  // Logical operators
	  Or:                   /(\|\||or(?!\w))/,         // ||, or
	  And:                  /(&&|and(?!\w))/,          // &&, and
	  Xor:                  /(\^|xor(?!\w))/,          // ^, xor
	  Not:                  /(!|not(?!\w))/,           // !, not

	  // this guy's special because '=' can mean either 'equal to'
	  // or 'becomes' depending on context
	  EqualToOrAssign:      /(=|to(?!\w))/,            // =, to

	  Add:                  /\+/,                      // +
	  Minus:                /-/,                       // -
	  Multiply:             /\*/,                      // *
	  Divide:               /\//,                      // /

	  AddAssign:            /\+=/,                     // +=
	  MinusAssign:          /-=/,                      // -=
	  MultiplyAssign:       /\*=/,                     // *=
	  DivideAssign:         /\/=/,                     // /=

	  Comment:              '//',                      // a run of text that we ignore

	  Identifier:           /[a-zA-Z0-9_:.]+/,         // a single word (used for functions)

	  CommandCall:          /([^>]|(?!>)[^>]+>)+(?=>>)/,// Command call

	  Text:                 /.*/,                      // a run of text until we hit other syntax.
	};
	/* eslint-enable key-spacing */

	var tokens = Tokens;

	/**
	 * A LexState object represents one of the states in which the lexer can be.
	 */
	class LexerState {
	  constructor() {
	    /** A list of transition for the given state. */
	    this.transitions = [];
	    /** A special, unique transition for matching spans of text in any state. */
	    this.textRule = null;
	    /**
	     * Whether or not this state is context-bound by indentation
	     * (will make the lexer emit Indent and Dedent tokens).
	     */
	    this.isTrackingNextIndentation = false;
	  }

	  /**
	   * addTransition - Define a new transition for this state.
	   *
	   * @param  {type} token - the token to match
	   * @param  {string} [state] - the state to which transition; if not provided, will
	   *                            remain in the same state.
	   * @param  {boolean} [delimitsText] - `true` if the token is a text delimiter. A text delimiters
	   *                                    is a token which should be considered as a token, even if it
	   *                                    doesn't start the line.
	   * @return {Object} - returns the LexState itself for chaining.
	   */
	  addTransition(token, state, delimitsText) {
	    this.transitions.push({
	      token: token,
	      regex: tokens[token],
	      state: state || null,
	      delimitsText: delimitsText || false,
	    });

	    return this; // Return this for chaining
	  }

	  /**
	   * addTextRule - Match all the way up to any of the other transitions in this state.
	   *               The text rule can only be added once.
	   *
	   * @param  {type} type  description
	   * @param  {type} state description
	   * @return {Object} - returns the LexState itself for chaining.
	   */
	  addTextRule(type, state) {
	    if (this.textRule) {
	      throw new Error('Cannot add more than one text rule to a state.');
	    }

	    // Go through the regex of the other transitions in this state, and create a regex that will
	    // match all text, up to any of those transitions.
	    const rules = [];
	    this.transitions.forEach((transition) => {
	      if (transition.delimitsText) {
	        // Surround the rule in parens
	        rules.push(`(${transition.regex.source})`);
	      }
	    });

	    // Join the rules that we got above on a |, then put them all into a negative lookahead.
	    const textPattern = `((?!${rules.join('|')}).)*`;
	    this.addTransition(type, state);

	    // Update the regex in the transition we just added to our new one.
	    this.textRule = this.transitions[this.transitions.length - 1];
	    this.textRule.regex = new RegExp(textPattern);

	    return this;
	  }

	  /**
	   * setTrackNextIndentation - tell this state wether to track indentation.
	   *
	   * @param  {boolean} track - `true` to track, `false` otherwise.
	   * @return {Object} - returns the LexState itself for chaining.
	   */
	  setTrackNextIndentation(track) {
	    this.isTrackingNextIndentation = track;
	    return this;
	  }
	}

	var lexerState = LexerState;

	/**
	 * @return {Object}  all states in which the lexer can be with their associated transitions.
	 */
	function makeStates() {
	  return {
	    base: new lexerState().addTransition('BeginCommand', 'command', true)
	                          .addTransition('OptionStart', 'link', true)
	                          .addTransition('ShortcutOption', 'shortcutOption')
	                          .addTextRule('Text'),

	    shortcutOption: new lexerState().setTrackNextIndentation(true)
	                                    .addTransition('BeginCommand', 'expression', true)
	                                    .addTextRule('Text', 'base'),

	    command: new lexerState().addTransition('If', 'expression')
	                             .addTransition('Else')
	                             .addTransition('ElseIf', 'expression')
	                             .addTransition('EndIf')
	                             .addTransition('Set', 'assignment')
	                             .addTransition('EndCommand', 'base', true)
	                             .addTransition('CommandCall', 'commandOrExpression')
	                             .addTextRule('Text'),

	    commandOrExpression: new lexerState().addTransition('EndCommand', 'base', true)
	                                         .addTextRule('Text'),

	    assignment: new lexerState().addTransition('Variable')
	                                .addTransition('EqualToOrAssign', 'expression')
	                                .addTransition('AddAssign', 'expression')
	                                .addTransition('MinusAssign', 'expression')
	                                .addTransition('MultiplyAssign', 'expression')
	                                .addTransition('DivideAssign', 'expression'),

	    expression: new lexerState().addTransition('EndCommand', 'base')
	                                .addTransition('Number')
	                                .addTransition('String')
	                                .addTransition('LeftParen')
	                                .addTransition('RightParen')
	                                .addTransition('EqualTo')
	                                .addTransition('EqualToOrAssign')
	                                .addTransition('NotEqualTo')
	                                .addTransition('GreaterThanOrEqualTo')
	                                .addTransition('GreaterThan')
	                                .addTransition('LessThanOrEqualTo')
	                                .addTransition('LessThan')
	                                .addTransition('Add')
	                                .addTransition('Minus')
	                                .addTransition('Multiply')
	                                .addTransition('Divide')
	                                .addTransition('And')
	                                .addTransition('Or')
	                                .addTransition('Xor')
	                                .addTransition('Not')
	                                .addTransition('Variable')
	                                .addTransition('Comma')
	                                .addTransition('True')
	                                .addTransition('False')
	                                .addTransition('Null')
	                                .addTransition('Identifier')
	                                .addTextRule(),

	    link: new lexerState().addTransition('OptionEnd', 'base', true)
	                          .addTransition('OptionDelimit', 'linkDestination', true)
	                          .addTextRule('Text'),

	    linkDestination: new lexerState().addTransition('Identifier')
	                                     .addTransition('OptionEnd', 'base'),
	  };
	}

	var states = {
	  makeStates: makeStates,
	};

	// Syncs with YarnSpinner@e0f6807,
	// see https://github.com/thesecretlab/YarnSpinner/blob/master/YarnSpinner/Lexer.cs



	// As opposed to the original C# implemntation which, tokenize the entire input, before emiting
	// a list of tokens, this parser will emit a token each time `lex()` is called. This change
	// accomodates the Jison parser. Given the lexer is not entirely context-free
	// (Off-side rule, lookaheads), context needs to be remembered between each `lex()` calls.
	class Lexer {
	  constructor() {
	    /** All the possible states for the lexer. */
	    this.states = states.makeStates();

	    /** Current state identifier. */
	    this.state = 'base';

	    /** Original text to lex. */
	    this.originalText = '';

	    /** Text to lex, splitted into an array of lines. */
	    this.lines = [];

	    // Properties used to keep track of the context we're in, while tokenizing each line.
	    /**
	     * Indentation tracker. Each time we encounter an identation, we push a
	     * new array which looks like: [indentationLevel, isBaseIndentation]. Basically,
	     * isBaseIndentation will be true only for the first level.
	     */
	    this.indentation = [[0, false]];

	    /**
	     * Set to true when a state required indentation tracking. Will be set to false, after a
	     * an indentation is found.
	     */
	    this.shouldTrackNextIndentation = false;

	    /**
	     * The previous level of identation, basically: this.indentation.last()[0].
	     */
	    this.previousLevelOfIndentation = 0;

	    // Reset the locations.
	    this.reset();
	  }

	  /**
	   * reset - Reset the lexer location, text and line number. Nothing fancy.
	   */
	  reset() {
	    // Locations, used by both the lexer and the Jison parser.
	    this.yytext = '';
	    this.yylloc = {
	      first_column: 1,
	      first_line: 1,
	      last_column: 1,
	      last_line: 1,
	    };
	    this.yylineno = 1;
	  }

	  /**
	   * lex - Lex the input and emit the next matched token.
	   *
	   * @return {string}  Emit the next token found.
	   */
	  lex() {
	    if (this.isAtTheEndOfText()) {
	      this.yytext = '';

	      // Now that we're at the end of the text, we'll emit as many
	      // `Dedent` as necessary, to get back to 0-indentation.
	      const indent = this.indentation.pop();
	      if (indent && indent[1]) { return 'Dedent'; }

	      return 'EndOfInput';
	    }

	    if (!this.isAtTheEndOfLine()) {
	      // Get the next token on the current line
	      return this.lexNextTokenOnCurrentLine();
	    } else if (!this.isAtTheEndOfText()) {
	      // Get the next line, and lex again.
	      return this.lexNextLine();
	    }

	    // Something went wrong. TODO: Throw exception?
	    return 'Invalid';
	  }

	  lexNextTokenOnCurrentLine() {
	    const thisIndentation = this.getCurrentLineIndentation();

	    if (this.shouldTrackNextIndentation &&
	        thisIndentation > this.previousLevelOfIndentation) {
	      this.indentation.push([thisIndentation, true]);
	      this.shouldTrackNextIndentation = false;

	      this.yylloc.first_column = this.yylloc.last_column;
	      this.yylloc.last_column += thisIndentation;
	      this.yytext = '';

	      return 'Indent';
	    } else if (thisIndentation < this.getLastRecordedIndentation()[0]) {
	      const indent = this.indentation.pop();
	      if (indent[1]) {
	        this.yytext = '';
	        this.previousLevelOfIndentation = this.getLastRecordedIndentation()[0];

	        return 'Dedent';
	      }

	      this.lexNextTokenOnCurrentLine();
	    }

	    if (thisIndentation === this.previousLevelOfIndentation && this.yylloc.last_column === 1) {
	      this.yylloc.last_column += thisIndentation;
	    }

	    if (this.getCurrentLine().substring(this.yylloc.last_column - 1).startsWith('//')) {
	      return this.lexNextLine();
	    }

	    for (const rule of this.getState().transitions) {
	      const match = this.getCurrentLine()
	                        .substring(this.yylloc.last_column - 1)
	                        .match(rule.regex);

	      // Only accept valid matches that are at the beginning of the text
	      if (match === null || match.index !== 0) {
	        continue;
	      }

	      // Take the matched text off the front of this.text
	      const matchedText = match[0];

	      // Tell the parser what the text for this token is
	      this.yytext = this.getCurrentLine().substr(this.yylloc.last_column - 1, matchedText.length);

	      if (rule.token === 'String') {
	        // If that's a String, we're removing the quotes and
	        // un-escaping double-escaped characters.
	        this.yytext = this.yytext.substring(1, this.yytext.length - 1)
	                                 .replace(/\\/g, '');
	      }

	      // Update our line and column info
	      this.yylloc.first_column = this.yylloc.last_column;
	      this.yylloc.last_column += matchedText.length;

	      // If the rule points to a new state, change it now
	      if (rule.state) {
	        this.setState(rule.state);

	        if (this.shouldTrackNextIndentation) {
	          if (this.getLastRecordedIndentation()[0] < thisIndentation) {
	            this.indentation.push([thisIndentation, false]);
	          }
	        }
	      }

	      const spaceMatch = this.getCurrentLine().substring(this.yylloc.last_column - 1)
	                                              .match(/^\s*/);

	      if (spaceMatch.length !== 0) {
	        this.yylloc.last_column += spaceMatch[0].length;
	      }

	      return rule.token;
	    }

	    // Something went wrong. TODO: Throw exception?
	    return 'Invalid';
	  }


	  /**
	   * lexNextLine - Start lexing the next line.
	   *
	   * @return {string}  the first token found on the next line.
	   */
	  lexNextLine() {
	    this.yylineno += 1;
	    const currentLine = this.getCurrentLine().replace(/\t/, '    ');

	    this.lines[this.yylineno - 1] = currentLine;
	    this.previousLevelOfIndentation = this.getLastRecordedIndentation()[0];

	    this.yytext = '';

	    this.yylloc = {
	      first_column: 1,
	      first_line: this.yylineno,
	      last_column: 1,
	      last_line: this.yylineno,
	    };

	    return this.lex();
	  }

	  // /////////////// Getters & Setters

	  /**
	   * setState - set the current state of the lexer.
	   *
	   * @param  {string} state name of the state
	   */
	  setState(state) {
	    if (this.states[state] === undefined) {
	      throw new Error(`Cannot set the unknown state [${state}]`);
	    }

	    this.state = state;
	    if (this.getState().isTrackingNextIndentation) {
	      this.shouldTrackNextIndentation = true;
	    }
	  }

	  /**
	   * setInput - Set the text on which perform lexical analysis.
	   *
	   * @param  {string} text the text to lex.
	   */
	  setInput(text) {
	    // Delete carriage return while keeping a similar semantic.
	    this.originalText = text.replace(/(\r\n)/g, '\n').replace(/\r/g, '\n').replace(/[\n\r]+$/, '');
	    // Transform the input into an array of lines.
	    this.lines = this.originalText.split('\n');
	    this.reset();
	  }

	  /**
	   * getState - Returns the full current state object (LexerState),
	   * rather than its identifier.
	   *
	   * @return {Object}  the state object.
	   */
	  getState() {
	    return this.states[this.state];
	  }

	  getCurrentLine() {
	    return this.lines[this.yylineno - 1];
	  }

	  setCurrentLine(line) {
	    this.lines[this.yylineno - 1] = line;
	  }

	  getCurrentLineIndentation() {
	    const match = this.getCurrentLine().match(/^(\s*)/g);

	    if (match === null && match[0] === null) {
	      return 0;
	    }

	    return match[0].length;
	  }

	  getLastRecordedIndentation() {
	    if (this.indentation.length === 0) {
	      return [0, false];
	    }

	    return this.indentation[this.indentation.length - 1];
	  }

	  // /////////////// Booleans tests
	  /**
	   * @return {boolean}  `true` when yylloc indicates that the end was reached.
	   */
	  isAtTheEndOfText() {
	    return this.isAtTheEndOfLine() &&
	           this.yylloc.first_line >= this.lines.length;
	  }

	  /**
	   * @return {boolean}  `true` when yylloc indicates that the end of the line was reached.
	   */
	  isAtTheEndOfLine() {
	    return this.yylloc.last_column >= this.getCurrentLine().length;
	  }
	}

	var lexer = Lexer;

	class Text { }
	class Shortcut { }
	class Jump { }
	class Link { }
	class Conditional { }
	class Assignment { }
	class Literal { }
	class Expression { }
	class Command { }

	var nodes = {
	  types: {
	    Text,
	    Shortcut,
			Jump,
	    Link,
	    Conditional,
	    Assignment,
	    Literal,
	    Expression,
	    Command,
	  },

	  RootNode: class {
	    constructor(dialogNodes) {
	      this.name = 'RootNode';
	      this.dialogNodes = dialogNodes || [];
	    }
	  },

	  // /////////////// Dialog Nodes

	  DialogNode: class {
	    constructor(content, name) {
	      this.type = 'DialogNode';
	      this.name = name || null;
	      this.content = content;
	    }
	  },

	  DialogOptionNode: class extends Shortcut {
	    constructor(text, content, lineNo) {
	      super();
	      this.type = 'DialogOptionNode';
	      this.text = text;
	      this.content = content;
	      this.lineNum = lineNo ? lineNo.first_line : -1;
	    }
	  },

	  ConditionalDialogOptionNode: class extends Shortcut {
	    constructor(text, content, conditionalExpression, lineNo) {
	      super();
	      this.type = 'ConditionalDialogOptionNode';
	      this.text = text;
	      this.content = content;
	      this.conditionalExpression = conditionalExpression;
	      this.lineNum = lineNo ? lineNo.first_line : -1;
	    }
	  },

	  // /////////////// Conditional Nodes
	  IfNode: class extends Conditional {
	    constructor(expression, statement) {
	      super();
	      this.type = 'IfNode';
	      this.expression = expression;
	      this.statement = statement;
	    }
	  },

	  IfElseNode: class extends Conditional {
	    constructor(expression, statement, elseStatement) {
	      super();
	      this.type = 'IfElseNode';
	      this.expression = expression;
	      this.statement = statement;
	      this.elseStatement = elseStatement;
	    }
	  },

	  ElseNode: class extends Conditional {
	    constructor(statement) {
	      super();
	      this.type = 'ElseNode';
	      this.statement = statement;
	    }
	  },

	  ElseIfNode: class extends Conditional {
	    constructor(expression, statement, elseStatement) {
	      super();
	      this.type = 'ElseIfNode';
	      this.expression = expression;
	      this.statement = statement;
	      this.elseStatement = elseStatement;
	    }
	  },

	  // /////////////// Contents Nodes
	  TextNode: class extends Text {
	    constructor(text, lineNo) {
	      super();
	      this.type = 'TextNode';
	      this.text = text;
	      this.lineNum = lineNo ? lineNo.first_line : -1;
	    }
	  },

	  JumpNode: class extends Jump {
	    constructor(identifier, lineNo) {
	      super();
	      this.type = 'JumpNode';
	      this.identifier = identifier;
	      this.lineNum = lineNo ? lineNo.first_line : -1;

	      this.selectable = true;
	    }
	  },

	  LinkNode: class extends Link {
	    constructor(text, identifier, lineNo) {
	      super();
	      this.type = 'LinkNode';
	      this.text = text || null;
	      this.identifier = identifier || this.text; // [[Destination Text]]
	      this.lineNum = lineNo ? lineNo.first_line : -1;

	      this.selectable = true;
	    }
	  },

	  // /////////////// Literal Nodes
	  NumericLiteralNode: class extends Literal {
	    constructor(numericLiteral) {
	      super();
	      this.type = 'NumericLiteralNode';
	      this.numericLiteral = numericLiteral;
	    }
	  },

	  StringLiteralNode: class extends Literal {
	    constructor(stringLiteral) {
	      super();
	      this.type = 'StringLiteralNode';
	      this.stringLiteral = stringLiteral;
	    }
	  },

	  BooleanLiteralNode: class extends Literal {
	    constructor(booleanLiteral) {
	      super();
	      this.type = 'BooleanLiteralNode';
	      this.booleanLiteral = booleanLiteral;
	    }
	  },

	  NullLiteralNode: class extends Literal {
	    constructor(nullLiteral) {
	      super();
	      this.type = 'NullLiteralNode';
	      this.nullLiteral = nullLiteral;
	    }
	  },

	  VariableNode: class extends Literal {
	    constructor(variableName) {
	      super();
	      this.type = 'VariableNode';
	      this.variableName = variableName;
	    }
	  },

	  // /////////////// Arithmetic Expression Nodes
	  UnaryMinusExpressionNode: class extends Expression {
	    constructor(expression) {
	      super();
	      this.type = 'UnaryMinusExpressionNode';
	      this.expression = expression;
	    }
	  },

	  ArithmeticExpressionNode: class extends Expression {
	    constructor(expression) {
	      super();
	      this.type = 'ArithmeticExpressionNode';
	      this.expression = expression;
	    }
	  },

	  ArithmeticExpressionAddNode: class extends Expression {
	    constructor(expression1, expression2) {
	      super();
	      this.type = 'ArithmeticExpressionAddNode';
	      this.expression1 = expression1;
	      this.expression2 = expression2;
	    }
	  },

	  ArithmeticExpressionMinusNode: class extends Expression {
	    constructor(expression1, expression2) {
	      super();
	      this.type = 'ArithmeticExpressionMinusNode';
	      this.expression1 = expression1;
	      this.expression2 = expression2;
	    }
	  },

	  ArithmeticExpressionMultiplyNode: class extends Expression {
	    constructor(expression1, expression2) {
	      super();
	      this.type = 'ArithmeticExpressionMultiplyNode';
	      this.expression1 = expression1;
	      this.expression2 = expression2;
	    }
	  },

	  ArithmeticExpressionDivideNode: class {
	    constructor(expression1, expression2) {
	      this.type = 'ArithmeticExpressionDivideNode';
	      this.expression1 = expression1;
	      this.expression2 = expression2;
	    }
	  },

	  // /////////////// Boolean Expression Nodes

	  BooleanExpressionNode: class extends Expression {
	    constructor(booleanExpression) {
	      super();
	      this.type = 'BooleanExpressionNode';
	      this.booleanExpression = booleanExpression;
	    }
	  },

	  NegatedBooleanExpressionNode: class extends Expression {
	    constructor(booleanExpression) {
	      super();
	      this.type = 'NegatedBooleanExpressionNode';
	      this.booleanExpression = booleanExpression;
	    }
	  },

	  BooleanOrExpressionNode: class extends Expression {
	    constructor(expression1, expression2) {
	      super();
	      this.type = 'BooleanOrExpressionNode';
	      this.expression1 = expression1;
	      this.expression2 = expression2;
	    }
	  },

	  BooleanAndExpressionNode: class extends Expression {
	    constructor(expression1, expression2) {
	      super();
	      this.type = 'BooleanAndExpressionNode';
	      this.expression1 = expression1;
	      this.expression2 = expression2;
	    }
	  },

	  BooleanXorExpressionNode: class extends Expression {
	    constructor(expression1, expression2) {
	      super();
	      this.type = 'BooleanXorExpressionNode';
	      this.expression1 = expression1;
	      this.expression2 = expression2;
	    }
	  },

	  EqualToExpressionNode: class extends Expression {
	    constructor(expression1, expression2) {
	      super();
	      this.type = 'EqualToExpressionNode';
	      this.expression1 = expression1;
	      this.expression2 = expression2;
	    }
	  },

	  NotEqualToExpressionNode: class extends Expression {
	    constructor(expression1, expression2) {
	      super();
	      this.type = 'EqualToExpressionNode';
	      this.expression1 = expression1;
	      this.expression2 = expression2;
	    }
	  },

	  GreaterThanExpressionNode: class extends Expression {
	    constructor(expression1, expression2) {
	      super();
	      this.type = 'GreaterThanExpressionNode';
	      this.expression1 = expression1;
	      this.expression2 = expression2;
	    }
	  },

	  GreaterThanOrEqualToExpressionNode: class extends Expression {
	    constructor(expression1, expression2) {
	      super();
	      this.type = 'GreaterThanOrEqualToExpressionNode';
	      this.expression1 = expression1;
	      this.expression2 = expression2;
	    }
	  },

	  LessThanExpressionNode: class extends Expression {
	    constructor(expression1, expression2) {
	      super();
	      this.type = 'LessThanExpressionNode';
	      this.expression1 = expression1;
	      this.expression2 = expression2;
	    }
	  },

	  LessThanOrEqualToExpressionNode: class extends Expression {
	    constructor(expression1, expression2) {
	      super();
	      this.type = 'LessThanOrEqualToExpressionNode';
	      this.expression1 = expression1;
	      this.expression2 = expression2;
	    }
	  },

	  // /////////////// Assignment Expression Nodes

	  SetVariableEqualToNode: class extends Assignment {
	    constructor(variableName, expression) {
	      super();
	      this.type = 'SetVariableEqualToNode';
	      this.variableName = variableName;
	      this.expression = expression;
	    }
	  },

	  SetVariableAddNode: class extends Assignment {
	    constructor(variableName, expression) {
	      super();
	      this.type = 'SetVariableAddNode';
	      this.variableName = variableName;
	      this.expression = expression;
	    }
	  },

	  SetVariableMinusNode: class extends Assignment {
	    constructor(variableName, expression) {
	      super();
	      this.type = 'SetVariableMinusNode';
	      this.variableName = variableName;
	      this.expression = expression;
	    }
	  },

	  SetVariableMultipyNode: class extends Assignment {
	    constructor(variableName, expression) {
	      super();
	      this.type = 'SetVariableMultipyNode';
	      this.variableName = variableName;
	      this.expression = expression;
	    }
	  },

	  SetVariableDivideNode: class extends Assignment {
	    constructor(variableName, expression) {
	      super();
	      this.type = 'SetVariableDivideNode';
	      this.variableName = variableName;
	      this.expression = expression;
	    }
	  },

	  // /////////////// Function Nodes

	  FunctionResultNode: class extends Literal {
	    constructor(functionName, args) {
	      super();
	      this.type = 'FunctionResultNode';
	      this.functionName = functionName;
	      this.args = args;
	    }
	  },

	  CommandNode: class extends Command {
	    constructor(command, lineNo) {
	      super();
	      this.type = 'CommandNode';
	      this.command = command;
	      this.lineNum = lineNo ? lineNo.first_line : -1;
	    }
	  },
	};

	class Result {}

	class TextResult extends Result {
	  /**
	   * Create a text display result
	   * @param {string} [text] text to be displayed
	   * @param {int} [lineNum] line number of the result in the node
	   */
	  constructor(text, yarnNodeData, lineNum) {
	    super();
	    this.text = text;
	    this.data = yarnNodeData;
	    this.lineNum = lineNum;
	  }
	}

	class CommandResult extends Result {
	  /**
	   * Return a command string
	   * @param {string} [text] text to be displayed
	   * @param {int} [lineNum] line number of the result in the node
	   */
	  constructor(text, yarnNodeData, lineNum) {
	    super();
	    this.text = text;
	    this.data = yarnNodeData;
	    this.lineNum = lineNum;
	  }
	}

	class OptionsResult extends Result {
	  /**
	   * Create a selectable list of options from the given list of text
	   * @param {string[]} [options] list of the text of options to be shown
	   * @param {int[]} [lineNum] list of the line numbers of options to be shown
	   */
	  constructor(options, lineNum) {
	    super();
	    this.options = options;
	    this.lineNum = lineNum;
	    this.selected = -1;
	  }

	  select(index) {
	    if (index < 0 || index >= this.options.length) {
	      throw new Error(`Cannot select option #${index}, there are only ${this.options.length} options`);
	    }
	    this.selected = index;
	  }
	}

	var results = { Result, TextResult, CommandResult, OptionsResult };

	class DefaultVariableStorage {
	  constructor() {
	    this.data = {};
	  }

	  set(name, value) {
	    this.data[name] = value;
	  }

	  get(name) {
	    return this.data[name];
	  }
	}

	var defaultVariableStorage = DefaultVariableStorage;

	const parser = parser_1.parser;



	parser.lexer = new lexer();
	parser.yy = nodes;



	const nodeTypes = nodes.types;

	class Runner {
	  constructor() {
	    this.yarnNodes = {};
	    this.variables = new defaultVariableStorage();
	    this.functions = {};
	    this.visited = {}; // Which nodes have been visited

	    this.registerFunction('visited', (args) => {
	      return !!this.visited[args[0]];
	    });
	  }

	  /**
	  * Loads the yarn node data into this.nodes and strips out unneeded information
	  * @param {any[]} data Object of exported yarn JSON data
	  */
	  load(data) {
	    for (const node of data) {
	      this.yarnNodes[node.title] = {
	        title: node.title,
	        tags: node.tags,
	        body: node.body,
	      };
	    }
	  }

	  /**
	   * Set a new variable storage object
	   * This must simply contain a 'get(name)' and 'set(name, value)' function
	   *
	   * Calling this function will clear any existing variable's values
	   */
	  setVariableStorage(storage) {
	    if (typeof storage.set !== 'function' || typeof storage.get !== 'function') {
	      throw new Error('Variable Storage object must contain both a "set" and "get" function');
	    }

	    this.variables = storage;
	  }

	  registerFunction(name, func) {
	    if (typeof func !== 'function') {
	      throw new Error('Registered function must be...well...a function');
	    }

	    this.functions[name] = func;
	  }

	  /**
	  * Generator to return each sequential dialogue result starting from the given node
	  * @param {string} [startNode] - The name of the yarn node to begin at
	  */
	  * run(startNode) {
	    const yarnNode = this.yarnNodes[startNode];

	    if (yarnNode === undefined) {
	      throw new Error(`Node "${startNode}" does not exist`);
	    }

	    this.visited[startNode] = true;

	    // Parse the entire node
	    const parserNodes = Array.from(parser.parse(yarnNode.body));
	    const yarnNodeData = {
	      title: yarnNode.title,
	      tags: yarnNode.tags.split(" "),
	      body: yarnNode.body,
	    };
	    yield* this.evalNodes(parserNodes, yarnNodeData);
	  }

	  /**
	   * Evaluate a list of parser nodes, yielding the ones that need to be seen by
	   * the user. Calls itself recursively if that is required by nested nodes
	   * @param {any[]} nodes
	   */
	  * evalNodes(nodes, yarnNodeData) {
	    if (!nodes) return;

	    let selectableNodes = null;
	    let jumpNode = null;

	    // Either nodeTypes.Link or nodeTypes.Shortcut depending on which we're accumulating
	    // (Since we don't want to accidentally lump shortcuts in with links)
	    let selectionType = null;

	    // Yield the individual user-visible results
	    // Need to accumulate all adjacent selectables into one list (hence some of
	    //  the weirdness here)
	    for (const node of nodes) {

	      if (node instanceof nodeTypes.Jump) {
	        jumpNode = node;
	      }
	      else if (selectableNodes !== null && node instanceof selectionType) {
	        // We're accumulating selection nodes, so add this one to the list
	        // TODO: handle conditional option nodes
	        selectableNodes.push(node);
	        // This is not a selectable node, so yield the options first
	      } else {
	        if (selectableNodes !== null) {
	          // We're accumulating selections, but this isn't one, so we're done
	          // Need to yield the accumulated selections first
	          yield* this.handleSelections(selectableNodes);
	          selectableNodes = null;
	          selectionType = null;
	        }

	        if (node instanceof nodeTypes.Text) {
	          // Just text to be returned
	          yield new results.TextResult(node.text, yarnNodeData, node.lineNum);
	        } else if (node instanceof nodeTypes.Link) {
	          // Start accumulating link nodes
	          selectionType = nodeTypes.Link;
	          selectableNodes = [node];
	        } else if (node instanceof nodeTypes.Shortcut) {
	          // Start accumulating shortcut nodes
	          selectionType = nodeTypes.Shortcut;
	          selectableNodes = [node];
	        } else if (node instanceof nodeTypes.Assignment) {
	          this.evaluateAssignment(node);
	        } else if (node instanceof nodeTypes.Conditional) {
	          // Run the results of the conditional
	          yield* this.evalNodes(this.evaluateConditional(node), yarnNodeData);
	        } else if (node instanceof nodeTypes.Command) {
	          if (node.command === 'stop') {
	            // Special command, halt execution
	            return;
	          }
	          yield new results.CommandResult(node.command, yarnNodeData, node.lineNum);
	        }
	      }
	    }

	    if (jumpNode !== null) {
	      yield* this.run(jumpNode.identifier);
	    }
	    else if (selectableNodes !== null) {
	      // At the end of the node, but we still need to handle any final options
	      yield* this.handleSelections(selectableNodes);
	    }
	  }

	  /**
	   * yield an options result then handle the subequent selection
	   * @param {any[]} selections
	   */
	  * handleSelections(selections) {
	    if (selections.length > 0 || selections[0] instanceof nodeTypes.Shortcut) {
	      // Multiple options to choose from (or just a single shortcut)
	      // Filter out any conditional dialog options that result to false
	      const filteredSelections = selections.filter((s) => {
	        if (s.type === 'ConditionalDialogOptionNode') {
	          return this.evaluateExpressionOrLiteral(s.conditionalExpression);
	        }

	        return true;
	      });

	      if (filteredSelections.length === 0) {
	        // No options to choose anymore
	        return;
	      }

	      const optionResults = new results.OptionsResult(filteredSelections.map((s) => {
	        return s.text;
	      }), filteredSelections.map((s) => {
	        return s.lineNum || -1;
	      }));

	      yield optionResults;

	      if (optionResults.selected !== -1) {
	        // Something was selected
	        const selectedOption = filteredSelections[optionResults.selected];
	        if (selectedOption.content) {
	          // Recursively go through the nodes nested within
	          yield* this.evalNodes(selectedOption.content);
	        } else if (selectedOption.identifier) {
	          // Run the new node
	          yield* this.run(selectedOption.identifier);
	        }
	      }
	    } else {
	      // If there's only one link option, automatically go to it
	      yield* this.run(selections[0].identifier);
	    }
	  }

	  /**
	   * Evaluates the given assignment node
	   */
	  evaluateAssignment(node) {
	    let result = this.evaluateExpressionOrLiteral(node.expression);
	    const currentVal = this.variables.get(node.variableName);

	    if (node.type === 'SetVariableAddNode') {
	      result += currentVal;
	    } else if (node.type === 'SetVariableMinusNode') {
	      result -= currentVal;
	    } else if (node.type === 'SetVariableMultiplyNode') {
	      result *= currentVal;
	    } else if (node.type === 'SetVariableDivideNode') {
	      result /= currentVal;
	    } else if (node.type === 'SetVariableEqualToNode') ; else {
	      throw new Error(`I don't recognize assignment type ${node.type}`);
	    }

	    this.variables.set(node.variableName, result);
	  }

	  /**
	   * Evaluates the given conditional node
	   * Returns the statements to be run as a result of it (if any)
	   */
	  evaluateConditional(node) {
	    if (node.type === 'IfNode') {
	      if (this.evaluateExpressionOrLiteral(node.expression)) {
	        return node.statement;
	      }
	    } else if (node.type === 'IfElseNode' || node.type === 'ElseIfNode') {
	      if (this.evaluateExpressionOrLiteral(node.expression)) {
	        return node.statement;
	      }

	      if (node.elseStatement) {
	        return this.evaluateConditional(node.elseStatement);
	      }
	    } else if (node.type === 'ElseNode') {
	      return node.statement;
	    }

	    return null;
	  }

	  /**
	   * Evaluates an expression or literal down to its final value
	   */
	  evaluateExpressionOrLiteral(node) {
	    if (node instanceof nodeTypes.Expression) {
	      if (node.type === 'UnaryMinusExpressionNode') {
	        return -1 * this.evaluateExpressionOrLiteral(node.expression);
	      } else if (node.type === 'ArithmeticExpressionNode') {
	        return this.evaluateExpressionOrLiteral(node.expression);
	      } else if (node.type === 'ArithmeticExpressionAddNode') {
	        return this.evaluateExpressionOrLiteral(node.expression1) +
	          this.evaluateExpressionOrLiteral(node.expression2);
	      } else if (node.type === 'ArithmeticExpressionMinusNode') {
	        return this.evaluateExpressionOrLiteral(node.expression1) -
	          this.evaluateExpressionOrLiteral(node.expression2);
	      } else if (node.type === 'ArithmeticExpressionMultiplyNode') {
	        return this.evaluateExpressionOrLiteral(node.expression1) *
	          this.evaluateExpressionOrLiteral(node.expression2);
	      } else if (node.type === 'ArithmeticExpressionDivideNode') {
	        return this.evaluateExpressionOrLiteral(node.expression1) /
	          this.evaluateExpressionOrLiteral(node.expression2);
	      } else if (node.type === 'BooleanExpressionNode') {
	        return this.evaluateExpressionOrLiteral(node.booleanExpression);
	      } else if (node.type === 'NegatedBooleanExpressionNode') {
	        return !this.evaluateExpressionOrLiteral(node.booleanExpression);
	      } else if (node.type === 'BooleanOrExpressionNode') {
	        return this.evaluateExpressionOrLiteral(node.expression1) ||
	          this.evaluateExpressionOrLiteral(node.expression2);
	      } else if (node.type === 'BooleanAndExpressionNode') {
	        return this.evaluateExpressionOrLiteral(node.expression1) &&
	          this.evaluateExpressionOrLiteral(node.expression2);
	      } else if (node.type === 'BooleanXorExpressionNode') {
	        return !this.evaluateExpressionOrLiteral(node.expression1) !== // Cheating
	          !this.evaluateExpressionOrLiteral(node.expression2);
	      } else if (node.type === 'EqualToExpressionNode') {
	        return this.evaluateExpressionOrLiteral(node.expression1) ===
	          this.evaluateExpressionOrLiteral(node.expression2);
	      } else if (node.type === 'NotEqualToExpressionNode') {
	        return this.evaluateExpressionOrLiteral(node.expression1) !==
	          this.evaluateExpressionOrLiteral(node.expression2);
	      } else if (node.type === 'GreaterThanExpressionNode') {
	        return this.evaluateExpressionOrLiteral(node.expression1) >
	          this.evaluateExpressionOrLiteral(node.expression2);
	      } else if (node.type === 'GreaterThanOrEqualToExpressionNode') {
	        return this.evaluateExpressionOrLiteral(node.expression1) >=
	          this.evaluateExpressionOrLiteral(node.expression2);
	      } else if (node.type === 'LessThanExpressionNode') {
	        return this.evaluateExpressionOrLiteral(node.expression1) <
	          this.evaluateExpressionOrLiteral(node.expression2);
	      } else if (node.type === 'LessThenOrEqualToExpressionNode') {
	        return this.evaluateExpressionOrLiteral(node.expression1) <=
	          this.evaluateExpressionOrLiteral(node.expression2);
	      }

	      throw new Error(`I don't recognize expression type ${node.type}`);
	    } else if (node instanceof nodeTypes.Literal) {
	      if (node.type === 'NumericLiteralNode') {
	        return parseFloat(node.numericLiteral);
	      } else if (node.type === 'StringLiteralNode') {
	        return node.stringLiteral;
	      } else if (node.type === 'BooleanLiteralNode') {
	        return node.booleanLiteral === 'true';
	      } else if (node.type === 'NullLiteralNode') {
	        return null;
	      } else if (node.type === 'VariableNode') {
	        return this.variables.get(node.variableName);
	      } else if (node.type === 'FunctionResultNode') {
	        if (this.functions[node.functionName]) {
	          return this.functions[node.functionName](node.args.map(this.evaluateExpressionOrLiteral));
	        }

	        throw new Error(`Function "${node.functionName}" not found`);
	      }

	      throw new Error(`I don't recognize literal type ${node.type}`);
	    } else {
	      throw new Error(`I don't recognize expression/literal type ${node.type}`);
	    }
	  }
	}

	var runner = {
	  Runner,
	  TextResult: results.TextResult,
	  CommandResult: results.CommandResult,
	  OptionsResult: results.OptionsResult,
	};

	var bondage = runner;

	return bondage;

})));
